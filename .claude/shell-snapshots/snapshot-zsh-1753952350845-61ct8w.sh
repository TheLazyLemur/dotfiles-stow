# Snapshot file
# Unset all aliases to avoid conflicts with functions
unalias -a 2>/dev/null || true
# Functions
→chroma/-alias.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-autoload.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-autorandr.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-awk.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-docker.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-example.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-fast-theme.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-fpath_peq.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-git.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-grep.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-hub.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-ionice.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-lab.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-make.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-nice.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-nmcli.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-node.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-ogit.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-perl.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-precommand.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-printf.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-ruby.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-scp.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-sh.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-source.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-ssh.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-subcommand.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-subversion.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-vim.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-whatis.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-which.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/-zinit.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
→chroma/main-chroma.ch () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
.fast-make-targets () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
.fast-read-ini-file () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
.fast-run-command () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
.fast-run-git-command () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
.fast-zts-read-all () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
.zinit-add-fpath () {
	[[ $1 = (-f|--front) ]] && {
		shift
		integer front=1 
	}
	.zinit-any-to-user-plugin "$1" ""
	local id_as="$1" add_dir="$2" user="${reply[-2]}" plugin="${reply[-1]}" 
	if (( front ))
	then
		fpath[1,0]=${${${(M)user:#%}:+$plugin}:-${ZINIT[PLUGINS_DIR]}/${id_as//\//---}}${add_dir:+/$add_dir} 
	else
		fpath+=(${${${(M)user:#%}:+$plugin}:-${ZINIT[PLUGINS_DIR]}/${id_as//\//---}}${add_dir:+/$add_dir}) 
	fi
}
.zinit-add-report () {
	[[ -n $1 ]] && {
		(( ${+builtins[zpmod]} && 0 )) && zpmod report-append "$1" "$2"$'\n' || ZINIT_REPORTS[$1]+="$2"$'\n' 
	}
	[[ ${ZINIT[DTRACE]} = 1 ]] && {
		(( ${+builtins[zpmod]} )) && zpmod report-append _dtrace/_dtrace "$2"$'\n' || ZINIT_REPORTS[_dtrace/_dtrace]+="$2"$'\n' 
	}
	return 0
}
.zinit-any-to-pid () {
	builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}
	builtin setopt extendedglob typesetsilent noshortloops rcquotes ${${${+REPLY}:#0}:+warncreateglobal}
	1=${~1} 2=${~2} 
	if [[ -n $2 ]]
	then
		if [[ $1 == (%|/)* || ( -z $1 && $2 == /* ) ]]
		then
			.zinit-util-shands-path $1${${(M)1#(%/?|%[^/]|/?)}:+/}$2
			REPLY=${${REPLY:#%*}:+%}$REPLY 
		else
			REPLY=$1${1:+/}$2 
		fi
		return 0
	fi
	if [[ $1 = (%|/|\~)* ]]
	then
		.zinit-util-shands-path $1
		REPLY=${${REPLY:#%*}:+%}$REPLY 
		return 0
	fi
	REPLY=${1//---//} 
	return 0
}
.zinit-any-to-user-plugin () {
	builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}
	builtin setopt extendedglob typesetsilent noshortloops rcquotes ${${${+reply}:#0}:+warncreateglobal}
	if [[ -n $2 ]]
	then
		2=${~2} 
		reply=(${1:-${${(M)2#/}:+%}} ${${${(M)1#%}:+$2}:-${2//---//}}) 
		return 0
	fi
	if [[ $1 = /* ]]
	then
		reply=(% $1) 
		return 0
	fi
	if [[ $1 = %* ]]
	then
		local -A map
		map=(ZPFX "$ZPFX" HOME $HOME SNIPPETS $ZINIT[SNIPPETS_DIR] PLUGINS $ZINIT[PLUGINS_DIR]) 
		reply=(% ${${1/(#b)(#s)%(${(~j:|:)${(@k)map}}|)/$map[$match[1]]}}) 
		reply[2]=${~reply[2]} 
		return 0
	fi
	1=${1//---//} 
	if [[ $1 = */* ]]
	then
		reply=(${1%%/*} ${1#*/}) 
		return 0
	fi
	reply=("" "${1:-_unknown}") 
	return 0
}
.zinit-compdef-clear () {
	local quiet="$1" count="${#ZINIT_COMPDEF_REPLAY}" 
	ZINIT_COMPDEF_REPLAY=() 
	[[ $quiet = -q ]] || +zi-log "Compdef-replay cleared (it had {num}${count}{rst} entries)."
}
.zinit-compdef-replay () {
	local quiet="$1" 
	typeset -a pos
	if [[ ${+functions[compdef]} = 0 ]]
	then
		+zi-log "{u-warn}Error{b-warn}:{rst} The {func}compinit{rst}" "function hasn't been loaded, cannot do {it}{cmd}compdef replay{rst}."
		return 1
	fi
	local cdf
	for cdf in "${ZINIT_COMPDEF_REPLAY[@]}"
	do
		pos=("${(z)cdf}") 
		[[ ${#pos[@]} = 1 && -z ${pos[-1]} ]] && continue
		pos=("${(Q)pos[@]}") 
		[[ $quiet = -q ]] || +zi-log "Running compdef: {cmd}${pos[*]}{rst}"
		compdef "${pos[@]}"
	done
	return 0
}
.zinit-diff () {
	.zinit-diff-functions "$1" "$2"
	.zinit-diff-options "$1" "$2"
	.zinit-diff-env "$1" "$2"
	.zinit-diff-parameter "$1" "$2"
}
.zinit-diff-env () {
	typeset -a tmp
	local IFS=" " 
	[[ $2 = begin ]] && {
		{
			[[ -z ${ZINIT[PATH_BEFORE__$uspl2]} ]] && tmp=("${(q)path[@]}") 
			ZINIT[PATH_BEFORE__$1]="${tmp[*]}" 
		}
		{
			[[ -z ${ZINIT[FPATH_BEFORE__$uspl2]} ]] && tmp=("${(q)fpath[@]}") 
			ZINIT[FPATH_BEFORE__$1]="${tmp[*]}" 
		}
	} || {
		tmp=("${(q)path[@]}") 
		ZINIT[PATH_AFTER__$1]+=" ${tmp[*]}" 
		tmp=("${(q)fpath[@]}") 
		ZINIT[FPATH_AFTER__$1]+=" ${tmp[*]}" 
	}
}
.zinit-diff-functions () {
	local uspl2="$1" 
	local cmd="$2" 
	[[ $cmd = begin ]] && {
		[[ -z ${ZINIT[FUNCTIONS_BEFORE__$uspl2]} ]] && ZINIT[FUNCTIONS_BEFORE__$uspl2]="${(j: :)${(qk)functions[@]}}" 
	} || ZINIT[FUNCTIONS_AFTER__$uspl2]+=" ${(j: :)${(qk)functions[@]}}" 
}
.zinit-diff-options () {
	local IFS=" " 
	[[ $2 = begin ]] && {
		[[ -z ${ZINIT[OPTIONS_BEFORE__$uspl2]} ]] && ZINIT[OPTIONS_BEFORE__$1]="${(kv)options[@]}" 
	} || ZINIT[OPTIONS_AFTER__$1]+=" ${(kv)options[@]}" 
}
.zinit-diff-parameter () {
	typeset -a tmp
	[[ $2 = begin ]] && {
		{
			[[ -z ${ZINIT[PARAMETERS_BEFORE__$uspl2]} ]] && ZINIT[PARAMETERS_BEFORE__$1]="${(j: :)${(qkv)parameters[@]}}" 
		}
	} || {
		ZINIT[PARAMETERS_AFTER__$1]+=" ${(j: :)${(qkv)parameters[@]}}" 
	}
}
.zinit-find-other-matches () {
	local pdir_path="$1" pbase="$2" limit="$3" 
	if [[ $limit == 1 ]]
	then
		reply=("$pdir_path"/*.plugin.zsh(DN)) 
	elif [[ $limit == 0 ]]
	then
		reply=("$pdir_path"/*.service.zsh(DN)) 
	else
		if [[ -e $pdir_path/init.zsh ]]
		then
			reply=("$pdir_path"/init.zsh) 
		elif [[ -e $pdir_path/$pbase.zsh-theme ]]
		then
			reply=("$pdir_path/$pbase".zsh-theme) 
		elif [[ -e $pdir_path/$pbase.theme.zsh ]]
		then
			reply=("$pdir_path/$pbase".theme.zsh) 
		else
			reply=("$pdir_path"/*.plugin.zsh(DN) "$pdir_path"/*.zsh-theme(DN) "$pdir_path"/*.lib.zsh(DN) "$pdir_path"/*.zsh(DN) "$pdir_path"/*.sh(DN) "$pdir_path"/.zshrc(DN)) 
		fi
	fi
	reply=("${(u)reply[@]}") 
	return $(( ${#reply} > 0 ? 0 : 1 ))
}
.zinit-formatter-auto () {
	emulate -L zsh -o extendedglob -o warncreateglobal -o typesetsilent
	local out in=$1 i wrk match spaces rest 
	integer mbegin mend
	local -a ice_order ecmds
	ice_order=(${(As:|:)ZINIT[ice-list]} ${(@)${(A@kons:|:)${ZINIT_EXTS[ice-mods]//\'\'/}}/(#s)<->-/}) 
	ecmds=(${ZINIT_EXTS[(I)z-annex subcommand:*]#z-annex subcommand:}) 
	in=${(j: :)${${(Z+Cn+)in}//[$'\t ']/$'\u00a0'}} 
	wrk=$in 
	while [[ $in == (#b)([[:space:]]#)([^[:space:]]##)(*) ]]
	do
		spaces=$match[1] 
		rest=$match[3] 
		wrk=${match[2]//---//} 
		REPLY=$wrk 
		if [[ ( $wrk == ([[:space:]]##|(#s))[0-9.]##([[:space:]]##|(#e)) && $rest == ([[:space:]]#|(#s))[sm]([[:space:]]##*|(#e)) ) || $wrk == ([[:space:]]##|(#s))[0-9.]##[sm]([[:space:]]##|(#e)) ]]
		then
			REPLY=$ZINIT[col-time]$wrk$ZINIT[col-rst] 
			if [[ $wrk != *[sm]* ]]
			then
				rest=$ZINIT[col-time]${(M)rest##[[:space:]]#[sm]}$ZINIT[col-rst]${rest##[[:space:]]#[sm]} 
			fi
		elif [[ $wrk == ([[:space:]]##|(#s))[0-9.]##([[:space:]]##|(#e)) ]]
		then
			REPLY=$ZINIT[col-num]$wrk$ZINIT[col-rst] 
		elif [[ $wrk == (#b)(((http|ftp)(|s)|ssh|scp|ntp|file)://[[:alnum:].:+/]##) ]]
		then
			.zinit-formatter-url $wrk
		elif [[ $wrk == (--|)(${(~j:|:)ice_order})[:=\"\'\!a-zA-Z0-9-]* ]]
		then
			REPLY=$ZINIT[col-ice]$wrk$ZINIT[col-rst] 
		elif [[ $wrk == (OMZ([PLT]|)|PZT([MLT]|)):* || $wrk == [^/]##/[^/]## || -d $ZINIT[PLUGINS_DIR]/${wrk//\//---} ]]
		then
			.zinit-formatter-pid $wrk
		elif [[ $wrk == (${~ZINIT[cmds]}|${(~j:|:)ecmds}) ]]
		then
			REPLY=$ZINIT[col-cmd]$wrk$ZINIT[col-rst] 
		elif type $1 &> /dev/null
		then
			REPLY=$ZINIT[col-bcmd]$wrk$ZINIT[col-rst] 
		elif [[ $wrk == (#b)(*)('<->'|'<–>'|'<—>')(*) || $wrk == (#b)(*)(…|–|—|↔|...)(*) ]]
		then
			local -A map=(… … - dsh – ndsh — mdsh '<->' ↔ '<–>' ↔ '<—>' ↔ ↔ ↔ ... …) 
			REPLY=$match[1]$ZINIT[col-$map[$wrk]]$match[3] 
		elif [[ $wrk == (#b)(*)([\'\`\"])([^\'\`\"]##)([\'\`\"])(*) ]]
		then
			local -A map=(\` bapo \' apo \" quo x\` baps x\' aps x\" quos) 
			local openq=$match[2] str=$match[3] closeq=$match[4] RST=$ZINIT[col-rst] 
			REPLY=$match[1]$ZINIT[col-$map[$openq]]$openq$RST$ZINIT[col-$map[x$openq]]$str$RST$ZINIT[col-$map[$closeq]]$closeq$RST$match[5] 
		fi
		in=$rest 
		out+=${spaces//$'\n'/$'\013\015'}$REPLY 
	done
	REPLY=${out//$'\u00a0'/ } 
}
.zinit-formatter-bar () {
	.zinit-formatter-bar-util ─ bar
}
.zinit-formatter-bar-util () {
	if [[ $LANG == (#i)*utf-8* ]]
	then
		ch=$1 
	else
		ch=- 
	fi
	REPLY=$ZINIT[col-$2]${(pl:COLUMNS-1::$ch:):-}$ZINIT[col-rst] 
}
.zinit-formatter-pid () {
	builtin emulate -L zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}
	local pbz=${(M)1##(#s)[[:space:]]##} 
	local kbz=${(M)1%%[[:space:]]##(#e)} 
	1=${1//((#s)[[:space:]]##|[[:space:]]##(#e))/} 
	((${+functions[.zinit-first]})) || source ${ZINIT[BIN_DIR]}/zinit-side.zsh
	.zinit-any-colorify-as-uspl2 "$1"
	pbz=${pbz/[[:blank:]]/ } 
	local kbz_rev="${(j::)${(@Oas::)kbz}}" 
	kbz="${(j::)${(@Oas::)${kbz_rev/[[:blank:]]/ }}}" 
	REPLY=$pbz$REPLY$kbz 
}
.zinit-formatter-th-bar () {
	.zinit-formatter-bar-util ━ th-bar
}
.zinit-formatter-url () {
	builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}
	if [[ $1 = (#b)([^:]#)(://|::)((([[:alnum:]._+-]##).([[:alnum:]_+-]##))|([[:alnum:].+_-]##))(|/(*)) ]]
	then
		match[9]=${match[9]//\//"%F{227}%B"/"%F{81}%b"} 
		if [[ -n $match[4] ]]
		then
			REPLY="$(builtin print -Pr -- %F{220}$match[1]%F{227}$match[2]\
%B%F{82}$match[5]\
%B%F{227}.\
%B%F{183}$match[6]%f%b)" 
		else
			REPLY="$(builtin print -Pr -- %F{220}$match[1]%F{227}$match[2]\
%B%F{82}$match[7]%f%b)" 
		fi
		if [[ -n $match[9] ]]
		then
			REPLY+="$(print -Pr -- \
%F{227}%B/%F{81}%b$match[9]%f%b)" 
		fi
	else
		REPLY=$ZINIT[col-url]$1$ZINIT[col-rst] 
	fi
}
.zinit-get-mtime-into () {
	if (( ZINIT[HAVE_ZSTAT] ))
	then
		local -a arr
		{
			zstat +mtime -A arr "$1"
		} 2> /dev/null
		: ${(P)2::="${arr[1]}"}
	else
		{
			: ${(P)2::="$(stat -c %Y "$1")"}
		} 2> /dev/null
	fi
}
.zinit-get-object-path () {
	local type="$1" id_as="$2" local_dir dirname 
	integer exists
	id_as="${ICE[id-as]:-$id_as}" 
	id_as="${${id_as#"${id_as%%[! $'\t']*}"}%/}" 
	for type in ${=${${(M)type:#AUTO}:+snippet plugin}:-$type}
	do
		if [[ $type == snippet ]]
		then
			dirname="${${id_as%%\?*}:t}" 
			local_dir="${${${id_as%%\?*}/:\/\//--}:h}" 
			[[ $local_dir = . ]] && local_dir=  || local_dir="${${${${${local_dir#/}//\//--}//=/-EQ-}//\?/-QM-}//\&/-AMP-}" 
			local_dir="${ZINIT[SNIPPETS_DIR]}${local_dir:+/$local_dir}" 
		else
			.zinit-any-to-user-plugin "$id_as"
			local_dir=${${${(M)reply[-2]:#%}:+${reply[2]}}:-${ZINIT[PLUGINS_DIR]}/${id_as//\//---}} 
			[[ $id_as == _local/* && -d $local_dir && ! -d $local_dir/._zinit ]] && command mkdir -p "$local_dir"/._zinit
			dirname="" 
		fi
		[[ -e $local_dir/${dirname:+$dirname/}._zinit || -e $local_dir/${dirname:+$dirname/}._zplugin ]] && exists=1 
		(( exists )) && break
	done
	reply=("$local_dir" "$dirname" "$exists") 
	REPLY="$local_dir${dirname:+/$dirname}" 
	return $(( 1 - exists ))
}
.zinit-ice () {
	builtin setopt localoptions noksharrays extendedglob warncreateglobal typesetsilent noshortloops
	integer retval
	local bit exts="${(j:|:)${(@)${(@Akons:|:)${ZINIT_EXTS[ice-mods]//\'\'/}}/(#s)<->-/}}" 
	for bit
	do
		[[ $bit = (#b)(--|)(${~ZINIT[ice-list]}${~exts})(*) ]] && ZINIT_ICES[${match[2]}]+="${ZINIT_ICES[${match[2]}]:+;}${match[3]#(:|=)}"  || break
		retval+=1 
	done
	[[ ${ZINIT_ICES[as]} = program ]] && ZINIT_ICES[as]=command 
	[[ -n ${ZINIT_ICES[on-update-of]} ]] && ZINIT_ICES[subscribe]="${ZINIT_ICES[subscribe]:-${ZINIT_ICES[on-update-of]}}" 
	[[ -n ${ZINIT_ICES[pick]} ]] && ZINIT_ICES[pick]="${ZINIT_ICES[pick]//\$ZPFX/${ZPFX%/}}" 
	if (( $+ZINIT_ICES[build] ))
	then
		+zi-log -- "{dbg} {ice}build{rst}: setting configure & make ices"
		ZINIT_ICES[configure]= 
		ZINIT_ICES[make]= 
	fi
	if (( $+ZINIT_ICES[configure] || $+ZINIT_ICES[cmake] || $+ZINIT_ICES[make] ))
	then
		ZINIT_ICES[null]= 
	fi
	(( $+ZINIT_ICES[configure] )) && ZINIT_ICES[configure]="${ZINIT_ICES[configure]}" 
	(( $+ZINIT_ICES[make] )) && ZINIT_ICES[make]="${ZINIT_ICES[make]:-install}" 
	return retval
}
.zinit-load () {
	typeset -F 3 SECONDS=0 
	local ___mode="$3" ___limit="$4" ___rst=0 ___retval=0 ___key 
	.zinit-any-to-user-plugin "$1" "$2"
	local ___user="${reply[-2]}" ___plugin="${reply[-1]}" ___id_as="${ICE[id-as]:-${reply[-2]}${${reply[-2]:#(%|/)*}:+/}${reply[-1]}}" 
	local ___pdir_path="${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\//---}}" 
	local ___pdir_orig="$___pdir_path" 
	ZINIT[CUR_USR]="$___user" ZINIT[CUR_PLUGIN]="$___plugin" ZINIT[CUR_USPL2]="$___id_as" 
	if [[ -n ${ICE[teleid]} ]]
	then
		.zinit-any-to-user-plugin "${ICE[teleid]}"
		___user="${reply[-2]}" ___plugin="${reply[-1]}" 
	else
		ICE[teleid]="$___user${${___user:#%}:+/}$___plugin" 
	fi
	.zinit-set-m-func set
	local -a ___arr
	reply=(${(on)ZINIT_EXTS2[(I)zinit hook:preinit-pre <->]} ${(on)ZINIT_EXTS[(I)z-annex hook:preinit-<-> <->]} ${(on)ZINIT_EXTS2[(I)zinit hook:preinit-post <->]}) 
	for ___key in "${reply[@]}"
	do
		___arr=("${(Q)${(z@)ZINIT_EXTS[$___key]:-$ZINIT_EXTS2[$___key]}[@]}") 
		"${___arr[5]}" plugin "$___user" "$___plugin" "$___id_as" "$___pdir_orig" "${${___key##(zinit|z-annex) hook:}%% <->}" load || return $(( 10 - $? ))
	done
	if [[ $___user != % && ! -d ${ZINIT[PLUGINS_DIR]}/${___id_as//\//---} ]]
	then
		(( ${+functions[.zinit-setup-plugin-dir]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-install.zsh" || return 1
		reply=("$___user" "$___plugin") REPLY=github 
		if (( ${+ICE[pack]} ))
		then
			if ! .zinit-get-package "$___user" "$___plugin" "$___id_as" "${ZINIT[PLUGINS_DIR]}/${___id_as//\//---}" "${ICE[pack]:-default}"
			then
				zle && {
					builtin print
					zle .reset-prompt
				}
				return 1
			fi
			___id_as="${ICE[id-as]:-${___user}${${___user:#(%|/)*}:+/}$___plugin}" 
		fi
		___user="${reply[-2]}" ___plugin="${reply[-1]}" 
		ICE[teleid]="$___user${${___user:#(%|/)*}:+/}$___plugin" 
		[[ $REPLY = snippet ]] && {
			ICE[id-as]="${ICE[id-as]:-$___id_as}" 
			.zinit-load-snippet $___plugin "" $___limit && return
			zle && {
				builtin print
				zle .reset-prompt
			}
			return 1
		}
		.zinit-setup-plugin-dir "$___user" "$___plugin" "$___id_as" "$REPLY"
		local rc="$?" 
		if [[ "$rc" -ne 0 ]]
		then
			zle && {
				builtin print
				zle .reset-prompt
			}
			return "$rc"
		fi
		zle && ___rst=1 
	fi
	ZINIT_SICE[$___id_as]= 
	.zinit-pack-ice "$___id_as"
	(( ${+ICE[cloneonly]} )) && return 0
	.zinit-register-plugin "$___id_as" "$___mode" "${ICE[teleid]}"
	if [[ -n ${ICE[param]} ]]
	then
		.zinit-setup-params && local -x ${(Q)reply[@]}
	fi
	reply=(${(on)ZINIT_EXTS[(I)z-annex hook:\!atinit-<-> <->]}) 
	for ___key in "${reply[@]}"
	do
		___arr=("${(Q)${(z@)ZINIT_EXTS[$___key]}[@]}") 
		"${___arr[5]}" plugin "$___user" "$___plugin" "$___id_as" "${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\//---}}" \!atinit || return $(( 10 - $? ))
	done
	[[ ${+ICE[atinit]} = 1 && $ICE[atinit] != '!'* ]] && {
		local ___oldcd="$PWD" 
		(( ${+ICE[nocd]} == 0 )) && {
			() {
				setopt localoptions noautopushd
				builtin cd -q "${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\//---}}"
			} && eval "${ICE[atinit]}"
			((1))
		} || eval "${ICE[atinit]}"
		() {
			setopt localoptions noautopushd
			builtin cd -q "$___oldcd"
		}
	}
	reply=(${(on)ZINIT_EXTS[(I)z-annex hook:atinit-<-> <->]}) 
	for ___key in "${reply[@]}"
	do
		___arr=("${(Q)${(z@)ZINIT_EXTS[$___key]}[@]}") 
		"${___arr[5]}" plugin "$___user" "$___plugin" "$___id_as" "${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\//---}}" atinit || return $(( 10 - $? ))
	done
	.zinit-load-plugin "$___user" "$___plugin" "$___id_as" "$___mode" "$___rst" "$___limit"
	___retval=$? 
	(( ${+ICE[notify]} == 1 )) && {
		[[ $___retval -eq 0 || -n ${(M)ICE[notify]#\!} ]] && {
			local msg
			eval "msg=\"${ICE[notify]#\!}\""
			+zinit-deploy-message @msg "$msg"
		} || +zinit-deploy-message @msg "notify: Plugin not loaded / loaded with problem, the return code: $___retval"
	}
	(( ${+ICE[reset-prompt]} == 1 )) && +zinit-deploy-message @___rst
	.zinit-set-m-func unset
	ZINIT[CUR_USR]= ZINIT[CUR_PLUGIN]= ZINIT[CUR_USPL2]= 
	ZINIT[TIME_INDEX]=$(( ${ZINIT[TIME_INDEX]:-0} + 1 )) 
	ZINIT[TIME_${ZINIT[TIME_INDEX]}_${___id_as//\//---}]=$SECONDS 
	ZINIT[AT_TIME_${ZINIT[TIME_INDEX]}_${___id_as//\//---}]=$EPOCHREALTIME 
	return ___retval
}
.zinit-load-ices () {
	local id_as="$1" ___key ___path 
	local -a ice_order
	ice_order=(${(As:|:)ZINIT[ice-list]} ${(@)${(A@kons:|:)${ZINIT_EXTS[ice-mods]//\'\'/}}/(#s)<->-/}) 
	___path="${ZINIT[PLUGINS_DIR]}/${id_as//\//---}"/._zinit 
	if [[ ! -d $___path ]]
	then
		if ! .zinit-get-object-path snippet "${id_as//\//---}"
		then
			return 1
		fi
		___path="$REPLY"/._zinit 
	fi
	for ___key in "${ice_order[@]}"
	do
		(( ${+ICE[$___key]} )) && [[ ${ICE[$___key]} != +* ]] && continue
		[[ -e $___path/$___key ]] && ICE[$___key]="$(<$___path/$___key)" 
	done
	[[ -n ${ICE[on-update-of]} ]] && ICE[subscribe]="${ICE[subscribe]:-${ICE[on-update-of]}}" 
	[[ ${ICE[as]} = program ]] && ICE[as]=command 
	[[ -n ${ICE[pick]} ]] && ICE[pick]="${ICE[pick]//\$ZPFX/${ZPFX%/}}" 
	return 0
}
.zinit-load-object () {
	local ___type="$1" ___id=$2 
	local -a ___opt
	___opt=(${@[3,-1]}) 
	if [[ $___type == snippet ]]
	then
		.zinit-load-snippet $___opt "$___id"
	elif [[ $___type == plugin ]]
	then
		.zinit-load "$___id" "" $___opt
	fi
	___retval+=$? 
	return __retval
}
.zinit-load-plugin () {
	local ___user="$1" ___plugin="$2" ___id_as="$3" ___mode="$4" ___rst="$5" ___limit="$6" ___correct=0 ___retval=0 
	local ___pbase="${${___plugin:t}%(.plugin.zsh|.zsh|.git)}" ___key 
	builtin set --
	[[ -o ksharrays ]] && ___correct=1 
	[[ -n ${ICE[(i)(\!|)(sh|bash|ksh|csh)]}${ICE[opts]} ]] && {
		local -a ___precm
		___precm=(builtin emulate ${${(M)${ICE[(i)(\!|)(sh|bash|ksh|csh)]}#\!}:+-R} ${${${ICE[(i)(\!|)(sh|bash|ksh|csh)]}#\!}:-zsh} ${${ICE[(i)(\!|)bash]}:+-${(s: :):-o noshglob -o braceexpand -o kshglob}} ${(s: :):-${${:-${(@s: :):--o}" "${(s: :)^ICE[opts]}}:#-o }} -c) 
	}
	[[ -z ${ICE[subst]} ]] && local ___builtin=builtin 
	[[ ${ICE[as]} = null || ${+ICE[null]} -eq 1 || ${+ICE[binary]} -eq 1 ]] && ICE[pick]="${ICE[pick]:-/dev/null}" 
	if [[ -n ${ICE[autoload]} ]]
	then
		:zinit-tmp-subst-autoload -Uz ${(s: :)${${${(s.;.)ICE[autoload]#[\!\#]}#[\!\#]}//(#b)((*)(->|=>|→)(*)|(*))/${match[2]:+$match[2] -S $match[4]}${match[5]:+${match[5]} -S ${match[5]}}}} ${${(M)ICE[autoload]:#*(->|=>|→)*}:+-C} ${${(M)ICE[autoload]#(?\!|\!)}:+-C} ${${(M)ICE[autoload]#(?\#|\#)}:+-I}
	fi
	if [[ ${ICE[as]} = command ]]
	then
		[[ ${+ICE[pick]} = 1 && -z ${ICE[pick]} ]] && ICE[pick]="${___id_as:t}" 
		reply=() 
		if [[ -n ${ICE[pick]} && ${ICE[pick]} != /dev/null ]]
		then
			reply=(${(M)~ICE[pick]##/*}(DN) $___pdir_path/${~ICE[pick]}(DN)) 
			[[ -n ${reply[1-correct]} ]] && ___pdir_path="${reply[1-correct]:h}" 
		fi
		[[ -z ${path[(er)$___pdir_path]} ]] && {
			[[ $___mode != light ]] && .zinit-diff-env "${ZINIT[CUR_USPL2]}" begin
			path=("${___pdir_path%/}" ${path[@]}) 
			[[ $___mode != light ]] && .zinit-diff-env "${ZINIT[CUR_USPL2]}" end
			.zinit-add-report "${ZINIT[CUR_USPL2]}" "$ZINIT[col-info2]$___pdir_path$ZINIT[col-rst] added to \$PATH"
		}
		[[ -n ${reply[1-correct]} && ! -x ${reply[1-correct]} ]] && command chmod a+x ${reply[@]}
		[[ ${ICE[atinit]} = '!'* || -n ${ICE[src]} || -n ${ICE[multisrc]} || ${ICE[atload][1]} = "!" ]] && {
			if [[ ${ZINIT[TMP_SUBST]} = inactive ]]
			then
				(( ${+functions[compdef]} )) && ZINIT[bkp-compdef]="${functions[compdef]}"  || builtin unset "ZINIT[bkp-compdef]"
				functions[compdef]=':zinit-tmp-subst-compdef "$@";' 
				ZINIT[TMP_SUBST]=1 
			else
				(( ++ ZINIT[TMP_SUBST] ))
			fi
		}
		local ZERO
		[[ $ICE[atinit] = '!'* ]] && {
			local ___oldcd="$PWD" 
			(( ${+ICE[nocd]} == 0 )) && {
				() {
					setopt localoptions noautopushd
					builtin cd -q "${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\//---}}"
				} && eval "${ICE[atinit#!]}"
				((1))
			} || eval "${ICE[atinit]#!}"
			() {
				setopt localoptions noautopushd
				builtin cd -q "$___oldcd"
			}
		}
		[[ -n ${ICE[src]} ]] && {
			ZERO="${${(M)ICE[src]##/*}:-$___pdir_orig/${ICE[src]}}" 
			(( ${+ICE[silent]} )) && {
				{
					[[ -n $___precm ]] && {
						builtin ${___precm[@]} 'source "$ZERO"'
						((1))
					} || {
						((1))
						$___builtin source "$ZERO"
					}
				} 2> /dev/null >&2
				(( ___retval += $? ))
				((1))
			} || {
				((1))
				{
					[[ -n $___precm ]] && {
						builtin ${___precm[@]} 'source "$ZERO"'
						((1))
					} || {
						((1))
						$___builtin source "$ZERO"
					}
				}
				(( ___retval += $? ))
			}
		}
		[[ -n ${ICE[multisrc]} ]] && {
			local ___oldcd="$PWD" 
			() {
				setopt localoptions noautopushd
				builtin cd -q "$___pdir_orig"
			}
			eval "reply=(${ICE[multisrc]})"
			() {
				setopt localoptions noautopushd
				builtin cd -q "$___oldcd"
			}
			local ___fname
			for ___fname in "${reply[@]}"
			do
				ZERO="${${(M)___fname:#/*}:-$___pdir_orig/$___fname}" 
				(( ${+ICE[silent]} )) && {
					{
						[[ -n $___precm ]] && {
							builtin ${___precm[@]} 'source "$ZERO"'
							((1))
						} || {
							((1))
							$___builtin source "$ZERO"
						}
					} 2> /dev/null >&2
					(( ___retval += $? ))
					((1))
				} || {
					((1))
					{
						[[ -n $___precm ]] && {
							builtin ${___precm[@]} 'source "$ZERO"'
							((1))
						} || {
							((1))
							$___builtin source "$ZERO"
						}
					}
					(( ___retval += $? ))
				}
			done
		}
		reply=(${(on)ZINIT_EXTS[(I)z-annex hook:\!atload-<-> <->]}) 
		for ___key in "${reply[@]}"
		do
			___arr=("${(Q)${(z@)ZINIT_EXTS[$___key]}[@]}") 
			"${___arr[5]}" plugin "$___user" "$___plugin" "$___id_as" "$___pdir_orig" \!atload
		done
		if [[ -n ${ICE[wrap]} ]]
		then
			(( ${+functions[.zinit-service]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-additional.zsh"
			.zinit-wrap-functions "$___user" "$___plugin" "$___id_as"
		fi
		[[ ${ICE[atload][1]} = "!" ]] && {
			.zinit-add-report "$___id_as" "Note: Starting to track the atload'!…' ice…"
			ZERO="$___pdir_orig/-atload-" 
			local ___oldcd="$PWD" 
			(( ${+ICE[nocd]} == 0 )) && {
				() {
					setopt localoptions noautopushd
					builtin cd -q "$___pdir_orig"
				} && builtin eval "${ICE[atload]#\!}"
			} || eval "${ICE[atload]#\!}"
			() {
				setopt localoptions noautopushd
				builtin cd -q "$___oldcd"
			}
		}
		[[ -n ${ICE[src]} || -n ${ICE[multisrc]} || ${ICE[atload][1]} = "!" ]] && {
			(( -- ZINIT[TMP_SUBST] == 0 )) && {
				ZINIT[TMP_SUBST]=inactive 
				builtin setopt noaliases
				(( ${+ZINIT[bkp-compdef]} )) && functions[compdef]="${ZINIT[bkp-compdef]}"  || unfunction compdef
				(( ZINIT[ALIASES_OPT] )) && builtin setopt aliases
			}
		}
	elif [[ ${ICE[as]} = completion ]]
	then
		((1))
	else
		if [[ -n ${ICE[pick]} ]]
		then
			[[ ${ICE[pick]} = /dev/null ]] && reply=(/dev/null)  || reply=(${(M)~ICE[pick]##/*}(DN) $___pdir_path/${~ICE[pick]}(DN)) 
		elif [[ -e $___pdir_path/$___pbase.plugin.zsh && $___limit -ne 0 ]]
		then
			reply=("$___pdir_path/$___pbase".plugin.zsh) 
		else
			.zinit-find-other-matches "$___pdir_path" "$___pbase" "$___limit"
		fi
		local ___fname="${reply[1-correct]:t}" 
		___pdir_path="${reply[1-correct]:h}" 
		.zinit-add-report "${ZINIT[CUR_USPL2]}" "Source $___fname ${${${(M)___mode:#light}:+(no reporting)}:-$ZINIT[col-info2](reporting enabled)$ZINIT[col-rst]}"
		[[ $___mode != light(|-b) ]] && .zinit-diff "${ZINIT[CUR_USPL2]}" begin
		.zinit-tmp-subst-on "${___mode:-load}"
		(( ${+ICE[blockf]} )) && {
			local -a fpath_bkp
			fpath_bkp=("${fpath[@]}") 
		}
		local ZERO="$___pdir_path/$___fname" 
		(( ${+ICE[aliases]} )) || builtin setopt noaliases
		[[ $ICE[atinit] = '!'* ]] && {
			local ___oldcd="$PWD" 
			(( ${+ICE[nocd]} == 0 )) && {
				() {
					setopt localoptions noautopushd
					builtin cd -q "${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\//---}}"
				} && eval "${ICE[atinit]#!}"
				((1))
			} || eval "${ICE[atinit]#1}"
			() {
				setopt localoptions noautopushd
				builtin cd -q "$___oldcd"
			}
		}
		(( ${+ICE[silent]} )) && {
			{
				[[ -n $___precm ]] && {
					builtin ${___precm[@]} 'source "$ZERO"'
					((1))
				} || {
					((1))
					$___builtin source "$ZERO"
				}
			} 2> /dev/null >&2
			(( ___retval += $? ))
			((1))
		} || {
			((1))
			{
				[[ -n $___precm ]] && {
					builtin ${___precm[@]} 'source "$ZERO"'
					((1))
				} || {
					((1))
					$___builtin source "$ZERO"
				}
			}
			(( ___retval += $? ))
		}
		[[ -n ${ICE[src]} ]] && {
			ZERO="${${(M)ICE[src]##/*}:-$___pdir_orig/${ICE[src]}}" 
			(( ${+ICE[silent]} )) && {
				{
					[[ -n $___precm ]] && {
						builtin ${___precm[@]} 'source "$ZERO"'
						((1))
					} || {
						((1))
						$___builtin source "$ZERO"
					}
				} 2> /dev/null >&2
				(( ___retval += $? ))
				((1))
			} || {
				((1))
				{
					[[ -n $___precm ]] && {
						builtin ${___precm[@]} 'source "$ZERO"'
						((1))
					} || {
						((1))
						$___builtin source "$ZERO"
					}
				}
				(( ___retval += $? ))
			}
		}
		[[ -n ${ICE[multisrc]} ]] && {
			local ___oldcd="$PWD" 
			() {
				setopt localoptions noautopushd
				builtin cd -q "$___pdir_orig"
			}
			eval "reply=(${ICE[multisrc]})"
			() {
				setopt localoptions noautopushd
				builtin cd -q "$___oldcd"
			}
			for ___fname in "${reply[@]}"
			do
				ZERO="${${(M)___fname:#/*}:-$___pdir_orig/$___fname}" 
				(( ${+ICE[silent]} )) && {
					{
						[[ -n $___precm ]] && {
							builtin ${___precm[@]} 'source "$ZERO"'
							((1))
						} || {
							((1))
							$___builtin source "$ZERO"
						}
					} 2> /dev/null >&2
					(( ___retval += $? ))
					((1))
				} || {
					{
						[[ -n $___precm ]] && {
							builtin ${___precm[@]} 'source "$ZERO"'
							((1))
						} || {
							((1))
							$___builtin source "$ZERO"
						}
					}
					(( ___retval += $? ))
				}
			done
		}
		reply=(${(on)ZINIT_EXTS[(I)z-annex hook:\!atload-<-> <->]}) 
		for ___key in "${reply[@]}"
		do
			___arr=("${(Q)${(z@)ZINIT_EXTS[$___key]}[@]}") 
			"${___arr[5]}" plugin "$___user" "$___plugin" "$___id_as" "$___pdir_orig" \!atload
		done
		if [[ -n ${ICE[wrap]} ]]
		then
			(( ${+functions[.zinit-service]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-additional.zsh"
			.zinit-wrap-functions "$___user" "$___plugin" "$___id_as"
		fi
		[[ ${ICE[atload][1]} = "!" ]] && {
			.zinit-add-report "$___id_as" "Note: Starting to track the atload'!…' ice…"
			ZERO="$___pdir_orig/-atload-" 
			local ___oldcd="$PWD" 
			(( ${+ICE[nocd]} == 0 )) && {
				() {
					setopt localoptions noautopushd
					builtin cd -q "$___pdir_orig"
				} && builtin eval "${ICE[atload]#\!}"
				((1))
			} || eval "${ICE[atload]#\!}"
			() {
				setopt localoptions noautopushd
				builtin cd -q "$___oldcd"
			}
		}
		(( ZINIT[ALIASES_OPT] )) && builtin setopt aliases
		(( ${+ICE[blockf]} )) && {
			fpath=("${fpath_bkp[@]}") 
		}
		.zinit-tmp-subst-off "${___mode:-load}"
		[[ $___mode != light(|-b) ]] && .zinit-diff "${ZINIT[CUR_USPL2]}" end
	fi
	[[ ${+ICE[atload]} = 1 && ${ICE[atload][1]} != "!" ]] && {
		ZERO="$___pdir_orig/-atload-" 
		local ___oldcd="$PWD" 
		(( ${+ICE[nocd]} == 0 )) && {
			() {
				setopt localoptions noautopushd
				builtin cd -q "$___pdir_orig"
			} && builtin eval "${ICE[atload]}"
			((1))
		} || eval "${ICE[atload]}"
		() {
			setopt localoptions noautopushd
			builtin cd -q "$___oldcd"
		}
	}
	reply=(${(on)ZINIT_EXTS[(I)z-annex hook:atload-<-> <->]}) 
	for ___key in "${reply[@]}"
	do
		___arr=("${(Q)${(z@)ZINIT_EXTS[$___key]}[@]}") 
		"${___arr[5]}" plugin "$___user" "$___plugin" "$___id_as" "$___pdir_orig" atload
	done
	(( ___rst )) && {
		builtin print
		zle .reset-prompt
	}
	return ___retval
}
.zinit-load-snippet () {
	typeset -F 3 SECONDS=0 
	local -a opts
	zparseopts -E -D -a opts f -command || {
		+zi-log "{u-warn}Error{b-warn}:{rst} Incorrect options (accepted ones: {opt}-f{rst}, {opt}--command{rst})."
		return 1
	}
	local url="$1" limit="$3" 
	[[ -n ${ICE[teleid]} ]] && url="${ICE[teleid]}" 
	builtin set --
	integer correct retval exists
	[[ -o ksharrays ]] && correct=1 
	[[ -n ${ICE[(i)(\!|)(sh|bash|ksh|csh)]}${ICE[opts]} ]] && {
		local -a precm
		precm=(builtin emulate ${${(M)${ICE[(i)(\!|)(sh|bash|ksh|csh)]}#\!}:+-R} ${${${ICE[(i)(\!|)(sh|bash|ksh|csh)]}#\!}:-zsh} ${${ICE[(i)(\!|)bash]}:+-${(s: :):-o noshglob -o braceexpand -o kshglob}} ${(s: :):-${${:-${(@s: :):--o}" "${(s: :)^ICE[opts]}}:#-o }} -c) 
	}
	url="${${url#"${url%%[! $'\t']*}"}%/}" 
	ICE[teleid]="${ICE[teleid]:-$url}" 
	[[ ${ICE[as]} = null || ${+ICE[null]} -eq 1 || ${+ICE[binary]} -eq 1 ]] && ICE[pick]="${ICE[pick]:-/dev/null}" 
	local local_dir dirname filename save_url="$url" 
	eval "url=\"$url\""
	local id_as="${ICE[id-as]:-$url}" 
	.zinit-set-m-func set
	if [[ -n ${ICE[param]} ]]
	then
		.zinit-setup-params && local -x ${(Q)reply[@]}
	fi
	.zinit-pack-ice "$id_as" ""
	[[ $url = *(${(~kj.|.)${(Mk)ZINIT_1MAP:#OMZ*}}|robbyrussell*oh-my-zsh|ohmyzsh/ohmyzsh)* ]] && local ZSH="${ZINIT[SNIPPETS_DIR]}" 
	.zinit-get-object-path snippet "$id_as"
	filename="${reply[-2]}" dirname="${reply[-2]}" 
	local_dir="${reply[-3]}" exists=${reply[-1]} 
	local -a arr
	local key
	reply=(${(on)ZINIT_EXTS2[(I)zinit hook:preinit-pre <->]} ${(on)ZINIT_EXTS[(I)z-annex hook:preinit-<-> <->]} ${(on)ZINIT_EXTS2[(I)zinit hook:preinit-post <->]}) 
	for key in "${reply[@]}"
	do
		arr=("${(Q)${(z@)ZINIT_EXTS[$key]:-$ZINIT_EXTS2[$key]}[@]}") 
		"${arr[5]}" snippet "$save_url" "$id_as" "$local_dir/$dirname" "${${key##(zinit|z-annex) hook:}%% <->}" load || return $(( 10 - $? ))
	done
	if [[ -n ${opts[(r)-f]} || $exists -eq 0 ]]
	then
		(( ${+functions[.zinit-download-snippet]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-install.zsh" || return 1
		.zinit-download-snippet "$save_url" "$url" "$id_as" "$local_dir" "$dirname" "$filename"
		retval=$? 
	fi
	(( ${+ICE[cloneonly]} || retval )) && return 0
	ZINIT_SNIPPETS[$id_as]="$id_as <${${ICE[svn]+svn}:-single file}>" 
	ZINIT[CUR_USPL2]="$id_as" ZINIT_REPORTS[$id_as]= 
	reply=(${(on)ZINIT_EXTS[(I)z-annex hook:\!atinit-<-> <->]}) 
	for key in "${reply[@]}"
	do
		arr=("${(Q)${(z@)ZINIT_EXTS[$key]}[@]}") 
		"${arr[5]}" snippet "$save_url" "$id_as" "$local_dir/$dirname" \!atinit || return $(( 10 - $? ))
	done
	(( ${+ICE[atinit]} )) && {
		local ___oldcd="$PWD" 
		(( ${+ICE[nocd]} == 0 )) && {
			() {
				setopt localoptions noautopushd
				builtin cd -q "$local_dir/$dirname"
			} && eval "${ICE[atinit]}"
			((1))
		} || eval "${ICE[atinit]}"
		() {
			setopt localoptions noautopushd
			builtin cd -q "$___oldcd"
		}
	}
	reply=(${(on)ZINIT_EXTS[(I)z-annex hook:atinit-<-> <->]}) 
	for key in "${reply[@]}"
	do
		arr=("${(Q)${(z@)ZINIT_EXTS[$key]}[@]}") 
		"${arr[5]}" snippet "$save_url" "$id_as" "$local_dir/$dirname" atinit || return $(( 10 - $? ))
	done
	local -a list
	local ZERO
	if [[ -z ${opts[(r)--command]} && ( -z ${ICE[as]} || ${ICE[as]} = null || ${+ICE[null]} -eq 1 || ${+ICE[binary]} -eq 1 ) ]]
	then
		if [[ ${ZINIT[TMP_SUBST]} = inactive ]]
		then
			(( ${+functions[compdef]} )) && ZINIT[bkp-compdef]="${functions[compdef]}"  || builtin unset "ZINIT[bkp-compdef]"
			functions[compdef]=':zinit-tmp-subst-compdef "$@";' 
			ZINIT[TMP_SUBST]=1 
		else
			(( ++ ZINIT[TMP_SUBST] ))
		fi
		if [[ -d $local_dir/$dirname/functions ]]
		then
			[[ -z ${fpath[(r)$local_dir/$dirname/functions]} ]] && fpath+=("$local_dir/$dirname/functions") 
			() {
				builtin setopt localoptions extendedglob
				autoload $local_dir/$dirname/functions/^([_.]*|prompt_*_setup|README*)(D-.N:t)
			}
		fi
		if (( ${+ICE[svn]} == 0 ))
		then
			[[ ${+ICE[pick]} = 0 ]] && list=("$local_dir/$dirname/$filename") 
			[[ -n ${ICE[pick]} ]] && list=(${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN)) 
		else
			if [[ -n ${ICE[pick]} ]]
			then
				list=(${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN)) 
			elif (( ${+ICE[pick]} == 0 ))
			then
				.zinit-find-other-matches "$local_dir/$dirname" "$filename" "$limit"
				list=(${reply[@]}) 
			fi
		fi
		if [[ -f ${list[1-correct]} ]]
		then
			ZERO="${list[1-correct]}" 
			(( ${+ICE[silent]} )) && {
				{
					[[ -n $precm ]] && {
						builtin ${precm[@]} 'source "$ZERO"'
						((1))
					} || {
						((1))
						builtin source "$ZERO"
					}
				} 2> /dev/null >&2
				(( retval += $? ))
				((1))
			} || {
				((1))
				{
					[[ -n $precm ]] && {
						builtin ${precm[@]} 'source "$ZERO"'
						((1))
					} || {
						((1))
						builtin source "$ZERO"
					}
				}
				(( retval += $? ))
			}
			(( 0 == retval )) && [[ $url = PZT::* || $url = https://github.com/sorin-ionescu/prezto/* ]] && zstyle ":prezto:module:${${id_as%/init.zsh}:t}" loaded 'yes'
		else
			[[ ${+ICE[silent]} -eq 1 || ( ${+ICE[pick]} -eq 1 && -z ${ICE[pick]} ) || ${ICE[pick]} = /dev/null ]] || {
				+zi-log "Snippet not loaded ({url}${id_as}{rst})"
				retval=1 
			}
		fi
		[[ -n ${ICE[src]} ]] && {
			ZERO="${${(M)ICE[src]##/*}:-$local_dir/$dirname/${ICE[src]}}" 
			(( ${+ICE[silent]} )) && {
				{
					[[ -n $precm ]] && {
						builtin ${precm[@]} 'source "$ZERO"'
						((1))
					} || {
						((1))
						builtin source "$ZERO"
					}
				} 2> /dev/null >&2
				(( retval += $? ))
				((1))
			} || {
				((1))
				{
					[[ -n $precm ]] && {
						builtin ${precm[@]} 'source "$ZERO"'
						((1))
					} || {
						((1))
						builtin source "$ZERO"
					}
				}
				(( retval += $? ))
			}
		}
		[[ -n ${ICE[multisrc]} ]] && {
			local ___oldcd="$PWD" 
			() {
				setopt localoptions noautopushd
				builtin cd -q "$local_dir/$dirname"
			}
			eval "reply=(${ICE[multisrc]})"
			() {
				setopt localoptions noautopushd
				builtin cd -q "$___oldcd"
			}
			local fname
			for fname in "${reply[@]}"
			do
				ZERO="${${(M)fname:#/*}:-$local_dir/$dirname/$fname}" 
				(( ${+ICE[silent]} )) && {
					{
						[[ -n $precm ]] && {
							builtin ${precm[@]} 'source "$ZERO"'
							((1))
						} || {
							((1))
							builtin source "$ZERO"
						}
					} 2> /dev/null >&2
					(( retval += $? ))
					((1))
				} || {
					((1))
					{
						[[ -n $precm ]] && {
							builtin ${precm[@]} 'source "$ZERO"'
							((1))
						} || {
							((1))
							builtin source "$ZERO"
						}
					}
					(( retval += $? ))
				}
			done
		}
		reply=(${(on)ZINIT_EXTS[(I)z-annex hook:\!atload-<-> <->]}) 
		for key in "${reply[@]}"
		do
			arr=("${(Q)${(z@)ZINIT_EXTS[$key]}[@]}") 
			"${arr[5]}" snippet "$save_url" "$id_as" "$local_dir/$dirname" \!atload
		done
		if [[ -n ${ICE[wrap]} ]]
		then
			(( ${+functions[.zinit-service]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-additional.zsh"
			.zinit-wrap-functions "$save_url" "" "$id_as"
		fi
		[[ ${ICE[atload][1]} = "!" ]] && {
			.zinit-add-report "$id_as" "Note: Starting to track the atload'!…' ice…"
			ZERO="$local_dir/$dirname/-atload-" 
			local ___oldcd="$PWD" 
			(( ${+ICE[nocd]} == 0 )) && {
				() {
					setopt localoptions noautopushd
					builtin cd -q "$local_dir/$dirname"
				} && builtin eval "${ICE[atload]#\!}"
				((1))
			} || eval "${ICE[atload]#\!}"
			() {
				setopt localoptions noautopushd
				builtin cd -q "$___oldcd"
			}
		}
		(( -- ZINIT[TMP_SUBST] == 0 )) && {
			ZINIT[TMP_SUBST]=inactive 
			builtin setopt noaliases
			(( ${+ZINIT[bkp-compdef]} )) && functions[compdef]="${ZINIT[bkp-compdef]}"  || unfunction compdef
			(( ZINIT[ALIASES_OPT] )) && builtin setopt aliases
		}
	elif [[ -n ${opts[(r)--command]} || ${ICE[as]} = command ]]
	then
		[[ ${+ICE[pick]} = 1 && -z ${ICE[pick]} ]] && ICE[pick]="${id_as:t}" 
		if (( ${+ICE[svn]} ))
		then
			if [[ -n ${ICE[pick]} ]]
			then
				list=(${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN)) 
				[[ -n ${list[1-correct]} ]] && local xpath="${list[1-correct]:h}" xfilepath="${list[1-correct]}" 
			else
				local xpath="$local_dir/$dirname" 
			fi
		else
			local xpath="$local_dir/$dirname" xfilepath="$local_dir/$dirname/$filename" 
			[[ -n ${ICE[pick]} ]] && {
				list=(${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN)) 
				[[ -n ${list[1-correct]} ]] && xpath="${list[1-correct]:h}" xfilepath="${list[1-correct]}" 
			}
		fi
		[[ -n $xpath && -z ${path[(er)$xpath]} ]] && path=("${xpath%/}" ${path[@]}) 
		[[ -n $xfilepath && -f $xfilepath && ! -x "$xfilepath" ]] && command chmod a+x "$xfilepath" ${list[@]:#$xfilepath}
		[[ -n ${ICE[src]} || -n ${ICE[multisrc]} || ${ICE[atload][1]} = "!" ]] && {
			if [[ ${ZINIT[TMP_SUBST]} = inactive ]]
			then
				(( ${+functions[compdef]} )) && ZINIT[bkp-compdef]="${functions[compdef]}"  || builtin unset "ZINIT[bkp-compdef]"
				functions[compdef]=':zinit-tmp-subst-compdef "$@";' 
				ZINIT[TMP_SUBST]=1 
			else
				(( ++ ZINIT[TMP_SUBST] ))
			fi
		}
		if [[ -n ${ICE[src]} ]]
		then
			ZERO="${${(M)ICE[src]##/*}:-$local_dir/$dirname/${ICE[src]}}" 
			(( ${+ICE[silent]} )) && {
				{
					[[ -n $precm ]] && {
						builtin ${precm[@]} 'source "$ZERO"'
						((1))
					} || {
						((1))
						builtin source "$ZERO"
					}
				} 2> /dev/null >&2
				(( retval += $? ))
				((1))
			} || {
				((1))
				{
					[[ -n $precm ]] && {
						builtin ${precm[@]} 'source "$ZERO"'
						((1))
					} || {
						((1))
						builtin source "$ZERO"
					}
				}
				(( retval += $? ))
			}
		fi
		[[ -n ${ICE[multisrc]} ]] && {
			local ___oldcd="$PWD" 
			() {
				setopt localoptions noautopushd
				builtin cd -q "$local_dir/$dirname"
			}
			eval "reply=(${ICE[multisrc]})"
			() {
				setopt localoptions noautopushd
				builtin cd -q "$___oldcd"
			}
			local fname
			for fname in "${reply[@]}"
			do
				ZERO="${${(M)fname:#/*}:-$local_dir/$dirname/$fname}" 
				(( ${+ICE[silent]} )) && {
					{
						[[ -n $precm ]] && {
							builtin ${precm[@]} 'source "$ZERO"'
							((1))
						} || {
							((1))
							builtin source "$ZERO"
						}
					} 2> /dev/null >&2
					(( retval += $? ))
					((1))
				} || {
					((1))
					{
						[[ -n $precm ]] && {
							builtin ${precm[@]} 'source "$ZERO"'
							((1))
						} || {
							((1))
							builtin source "$ZERO"
						}
					}
					(( retval += $? ))
				}
			done
		}
		reply=(${(on)ZINIT_EXTS[(I)z-annex hook:\!atload-<-> <->]}) 
		for key in "${reply[@]}"
		do
			arr=("${(Q)${(z@)ZINIT_EXTS[$key]}[@]}") 
			"${arr[5]}" snippet "$save_url" "$id_as" "$local_dir/$dirname" \!atload
		done
		if [[ -n ${ICE[wrap]} ]]
		then
			(( ${+functions[.zinit-service]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-additional.zsh"
			.zinit-wrap-functions "$save_url" "" "$id_as"
		fi
		[[ ${ICE[atload][1]} = "!" ]] && {
			.zinit-add-report "$id_as" "Note: Starting to track the atload'!…' ice…"
			ZERO="$local_dir/$dirname/-atload-" 
			local ___oldcd="$PWD" 
			(( ${+ICE[nocd]} == 0 )) && {
				() {
					setopt localoptions noautopushd
					builtin cd -q "$local_dir/$dirname"
				} && builtin eval "${ICE[atload]#\!}"
				((1))
			} || eval "${ICE[atload]#\!}"
			() {
				setopt localoptions noautopushd
				builtin cd -q "$___oldcd"
			}
		}
		[[ -n ${ICE[src]} || -n ${ICE[multisrc]} || ${ICE[atload][1]} = "!" ]] && {
			(( -- ZINIT[TMP_SUBST] == 0 )) && {
				ZINIT[TMP_SUBST]=inactive 
				builtin setopt noaliases
				(( ${+ZINIT[bkp-compdef]} )) && functions[compdef]="${ZINIT[bkp-compdef]}"  || unfunction compdef
				(( ZINIT[ALIASES_OPT] )) && builtin setopt aliases
			}
		}
	elif [[ ${ICE[as]} = completion ]]
	then
		((1))
	fi
	(( ${+ICE[atload]} )) && [[ ${ICE[atload][1]} != "!" ]] && {
		ZERO="$local_dir/$dirname/-atload-" 
		local ___oldcd="$PWD" 
		(( ${+ICE[nocd]} == 0 )) && {
			() {
				setopt localoptions noautopushd
				builtin cd -q "$local_dir/$dirname"
			} && builtin eval "${ICE[atload]}"
			((1))
		} || eval "${ICE[atload]}"
		() {
			setopt localoptions noautopushd
			builtin cd -q "$___oldcd"
		}
	}
	reply=(${(on)ZINIT_EXTS[(I)z-annex hook:atload-<-> <->]}) 
	for key in "${reply[@]}"
	do
		arr=("${(Q)${(z@)ZINIT_EXTS[$key]}[@]}") 
		"${arr[5]}" snippet "$save_url" "$id_as" "$local_dir/$dirname" atload
	done
	(( ${+ICE[notify]} == 1 )) && {
		[[ $retval -eq 0 || -n ${(M)ICE[notify]#\!} ]] && {
			local msg
			eval "msg=\"${ICE[notify]#\!}\""
			+zinit-deploy-message @msg "$msg"
		} || +zinit-deploy-message @msg "notify: Plugin not loaded / loaded with problem, the return code: $retval"
	}
	(( ${+ICE[reset-prompt]} == 1 )) && +zinit-deploy-message @rst
	ZINIT[CUR_USPL2]= 
	ZINIT[TIME_INDEX]=$(( ${ZINIT[TIME_INDEX]:-0} + 1 )) 
	ZINIT[TIME_${ZINIT[TIME_INDEX]}_${id_as}]=$SECONDS 
	ZINIT[AT_TIME_${ZINIT[TIME_INDEX]}_${id_as}]=$EPOCHREALTIME 
	.zinit-set-m-func unset
	return retval
}
.zinit-main-message-formatter () {
	if [[ -z $1 && -z $2 && -z $3 ]]
	then
		REPLY="" 
		return
	fi
	local append influx in_prepend
	if [[ $2 == (b|u|it|st|nb|nu|nit|nst) ]]
	then
		append=$ZINIT[col-$2] 
	elif [[ $2 == (…|ndsh|mdsh|mmdsh|-…|lr|) || -z $2 || -z $ZINIT[col-$2] ]]
	then
		if [[ $ZINIT[__last-formatter-code] != (…|ndsh|mdsh|mmdsh|-…|lr|rst|nl|) ]]
		then
			in_prepend=$ZINIT[col-$ZINIT[__last-formatter-code]] 
			influx=$ZINIT[col-$ZINIT[__last-formatter-code]] 
		fi
	else
		append=$ZINIT[col-rst] 
	fi
	REPLY=$in_prepend${ZINIT[col-$2]:-$1}$influx$3$append 
	local nl=$'\n' vertical=$'\013' carriager=$'\015' 
	REPLY=${REPLY//$nl/$vertical$carriager} 
}
.zinit-pack-ice () {
	ZINIT_SICE[$1${1:+${2:+/}}$2]+="${(j: :)${(qkv)ICE[@]}} " 
	ZINIT_SICE[$1${1:+${2:+/}}$2]="${ZINIT_SICE[$1${1:+${2:+/}}$2]# }" 
	return 0
}
.zinit-parse-opts () {
	builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}
	reply=("${(@)${@[2,-1]//([  $'\t']##|(#s))(#b)(${(~j.|.)${(@s.|.)___opt_map[$1]}})(#B)([  $'\t']##|(#e))/${OPTS[${___opt_map[${match[1]}]%%:*}]::=1}ß←↓→}:#1ß←↓→}") 
}
.zinit-prepare-home () {
	[[ -n ${ZINIT[HOME_READY]} ]] && return
	ZINIT[HOME_READY]=1 
	[[ ! -d ${ZINIT[HOME_DIR]} ]] && {
		command mkdir -p "${ZINIT[HOME_DIR]}"
		command chmod go-w "${ZINIT[HOME_DIR]}"
		command mkdir -p "${ZPFX:-ZINIT[HOME_DIR]/polaris}/bin"
	}
	[[ ! -d ${ZINIT[PLUGINS_DIR]}/_local---zinit ]] && {
		command rm -rf "${ZINIT[PLUGINS_DIR]:-${TMPDIR:-/tmp}/132bcaCAB}/_local---zplugin"
		command mkdir -p "${ZINIT[PLUGINS_DIR]}/_local---zinit"
		command chmod go-w "${ZINIT[PLUGINS_DIR]}"
		command ln -s "${ZINIT[BIN_DIR]}/_zinit" "${ZINIT[PLUGINS_DIR]}/_local---zinit"
		command mkdir -p "${ZPFX:-ZINIT[HOME_DIR]/polaris}/bin"
		(( ${+functions[.zinit-setup-plugin-dir]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-install.zsh" || return 1
		(( ${+functions[.zinit-confirm]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-autoload.zsh" || return 1
		.zinit-clear-completions &> /dev/null
		.zinit-compinit &> /dev/null
	}
	[[ ! -d ${ZINIT[COMPLETIONS_DIR]} ]] && {
		command mkdir "${ZINIT[COMPLETIONS_DIR]}"
		command chmod go-w "${ZINIT[COMPLETIONS_DIR]}"
		command ln -s "${ZINIT[PLUGINS_DIR]}/_local---zinit/_zinit" "${ZINIT[COMPLETIONS_DIR]}"
		command mkdir -p "${ZPFX:-ZINIT[HOME_DIR]/polaris}/bin"
		(( ${+functions[.zinit-setup-plugin-dir]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-install.zsh" || return 1
		.zinit-compinit &> /dev/null
	}
	[[ ! -d ${ZINIT[SNIPPETS_DIR]} ]] && {
		command mkdir -p "${ZINIT[SNIPPETS_DIR]}/OMZ::plugins"
		command chmod go-w "${ZINIT[SNIPPETS_DIR]}"
		(
			builtin cd ${ZINIT[SNIPPETS_DIR]}
			command ln -s OMZ::plugins plugins
		)
		command mkdir -p "${ZINIT[SERVICES_DIR]}"
		command chmod go-w "${ZINIT[SERVICES_DIR]}"
		command mkdir -p "${ZPFX:-ZINIT[HOME_DIR]/polaris}/bin"
	}
	[[ ! -d ${~ZINIT[MAN_DIR]}/man9 ]] && {
		command mkdir -p ${~ZINIT[MAN_DIR]}/man{1..9} 2> /dev/null
	}
	[[ ! -f $ZINIT[MAN_DIR]/man1/zinit.1 || $ZINIT[MAN_DIR]/man1/zinit.1 -ot $ZINIT[BIN_DIR]/doc/zinit.1 ]] && {
		command mkdir -p $ZINIT[MAN_DIR]/man1
		command cp -f $ZINIT[BIN_DIR]/doc/zinit.1 $ZINIT[MAN_DIR]/man1
	}
}
.zinit-register-plugin () {
	local uspl2="$1" mode="$2" teleid="$3" 
	integer ret=0 
	if [[ -z ${ZINIT_REGISTERED_PLUGINS[(r)$uspl2]} ]]
	then
		ZINIT_REGISTERED_PLUGINS+=("$uspl2") 
	else
		[[ -z ${ZINIT[TEST]}${${+ICE[wait]}:#0}${ICE[load]}${ICE[subscribe]} && ${ZINIT[MUTE_WARNINGS]} != (1|true|on|yes) ]] && +zi-log "{u-warn}Warning{b-warn}:{rst} plugin {apo}\`{pid}${uspl2}{apo}\`{rst} already registered, will overwrite-load."
		ret=1 
	fi
	zsh_loaded_plugins+=("$teleid") 
	[[ $mode == light ]] && ZINIT[STATES__$uspl2]=1  || ZINIT[STATES__$uspl2]=2 
	ZINIT_REPORTS[$uspl2]= ZINIT_CUR_BIND_MAP=(empty 1) 
	ZINIT[FUNCTIONS_BEFORE__$uspl2]= ZINIT[FUNCTIONS_AFTER__$uspl2]= 
	ZINIT[FUNCTIONS__$uspl2]= 
	ZINIT[ZSTYLES__$uspl2]= ZINIT[BINDKEYS__$uspl2]= 
	ZINIT[ALIASES__$uspl2]= 
	ZINIT[WIDGETS_SAVED__$uspl2]= ZINIT[WIDGETS_DELETE__$uspl2]= 
	ZINIT[OPTIONS__$uspl2]= ZINIT[PATH__$uspl2]= 
	ZINIT[OPTIONS_BEFORE__$uspl2]= ZINIT[OPTIONS_AFTER__$uspl2]= 
	ZINIT[FPATH__$uspl2]= 
	return ret
}
.zinit-run () {
	if [[ $1 = (-l|--last) ]]
	then
		{
			set -- "${ZINIT[last-run-plugin]:-$(<${ZINIT[BIN_DIR]}/last-run-object.txt)}" "${@[2-correct,-1]}"
		} &> /dev/null
		[[ -z $1 ]] && {
			+zi-log "{u-warn}Error{b-warn}:{rst} No recent plugin-ID saved on the disk yet, please specify" "it as the first argument, i.e.{ehi}: {cmd}zi run {pid}usr/plg{slight} {…}the code to run{…} "
			return 1
		}
	else
		integer ___nolast=1 
	fi
	.zinit-any-to-user-plugin "$1" ""
	local ___id_as="$1" ___user="${reply[-2]}" ___plugin="${reply[-1]}" ___oldpwd="$PWD" 
	() {
		builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}
		builtin cd -q ${${${(M)___user:#%}:+$___plugin}:-${ZINIT[PLUGINS_DIR]}/${___id_as//\//---}} &> /dev/null || {
			.zinit-get-object-path snippet "$___id_as"
			builtin cd -q $REPLY &> /dev/null
		}
	}
	if (( $? == 0 ))
	then
		(( ___nolast )) && {
			builtin print -r "$1" >| ${ZINIT[BIN_DIR]}/last-run-object.txt
		}
		ZINIT[last-run-plugin]="$1" 
		eval "${@[2-correct,-1]}"
		() {
			setopt localoptions noautopushd
			builtin cd -q "$___oldpwd"
		}
	else
		+zi-log "{u-warn}Error{b-warn}:{rst} no such plugin or snippet."
	fi
}
.zinit-run-task () {
	local ___pass="$1" ___t="$2" ___tpe="$3" ___idx="$4" ___mode="$5" ___id="${(Q)6}" ___opt="${(Q)7}" ___action ___s=1 ___retval=0 
	local -A ICE ZINIT_ICE
	ICE=("${(@Q)${(z@)ZINIT[WAIT_ICE_${___idx}]}}") 
	ZINIT_ICE=("${(kv)ICE[@]}") 
	local ___id_as=${ICE[id-as]:-$___id} 
	if [[ $___pass = 1 && ${${ICE[wait]#\!}%%[^0-9]([^0-9]|)([^0-9]|)([^0-9]|)} = <-> ]]
	then
		___action="${(M)ICE[wait]#\!}load" 
	elif [[ $___pass = 1 && -n ${ICE[wait]#\!} ]] && {
			eval "${ICE[wait]#\!}" || [[ $(( ___s=0 )) = 1 ]]
		}
	then
		___action="${(M)ICE[wait]#\!}load" 
	elif [[ -n ${ICE[load]#\!} && -n $(( ___s=0 )) && $___pass = 3 && -z ${ZINIT_REGISTERED_PLUGINS[(r)$___id_as]} ]] && eval "${ICE[load]#\!}"
	then
		___action="${(M)ICE[load]#\!}load" 
	elif [[ -n ${ICE[unload]#\!} && -n $(( ___s=0 )) && $___pass = 2 && -n ${ZINIT_REGISTERED_PLUGINS[(r)$___id_as]} ]] && eval "${ICE[unload]#\!}"
	then
		___action="${(M)ICE[unload]#\!}remove" 
	elif [[ -n ${ICE[subscribe]#\!} && -n $(( ___s=0 )) && $___pass = 3 ]] && {
			local -a fts_arr
			eval "fts_arr=( ${ICE[subscribe]}(DNms-$(( EPOCHSECONDS -
                 ZINIT[fts-${ICE[subscribe]}] ))) ); (( \${#fts_arr} ))" && {
				ZINIT[fts-${ICE[subscribe]}]="$EPOCHSECONDS" 
				___s=${+ICE[once]} 
			} || (( 0 ))
		}
	then
		___action="${(M)ICE[subscribe]#\!}load" 
	fi
	if [[ $___action = *load ]]
	then
		if [[ $___tpe = p* ]]
		then
			.zinit-load "${(@)=___id}" "" "$___mode" ${___tpe#p}
			(( ___retval += $? ))
		elif [[ $___tpe = s* ]]
		then
			.zinit-load-snippet $___opt "$___id" "" ${___tpe#s}
			(( ___retval += $? ))
		fi
		if [[ $___tpe = p1 || $___tpe = s1 ]]
		then
			(( ${+functions[.zinit-service]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-additional.zsh"
			zpty -b "${___id//\//:} / ${ICE[service]}" '.zinit-service '"${(M)___tpe#?}"' "$___mode" "$___id"'
		fi
		(( ${+ICE[silent]} == 0 && ${+ICE[lucid]} == 0 && ___retval == 0 )) && zle && zle -M "Loaded $___id"
	elif [[ $___action = *remove ]]
	then
		(( ${+functions[.zinit-confirm]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-autoload.zsh" || return 1
		[[ $___tpe = p ]] && .zinit-unload "$___id_as" "" -q
		(( ${+ICE[silent]} == 0 && ${+ICE[lucid]} == 0 && ___retval == 0 )) && zle && zle -M "Unloaded $___id_as"
	fi
	[[ ${REPLY::=$___action} = \!* ]] && zle && zle .reset-prompt
	return ___s
}
.zinit-set-m-func () {
	if [[ $1 == set ]]
	then
		ZINIT[___m_bkp]="${functions[m]}" 
		setopt noaliases
		functions[m]="${functions[+zi-log]}" 
		setopt aliases
	elif [[ $1 == unset ]]
	then
		if [[ -n ${ZINIT[___m_bkp]} ]]
		then
			setopt noaliases
			functions[m]="${ZINIT[___m_bkp]}" 
			setopt aliases
		else
			noglob unset functions[m]
		fi
	else
		+zi-log "{error}ERROR #1"
		return 1
	fi
}
.zinit-setup-params () {
	builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}
	reply=(${(@)${(@s.;.)ICE[param]}/(#m)*/${${MATCH%%(-\>|→|=\>)*}//((#s)[[:space:]]##|[[:space:]]##(#e))}${${(M)MATCH#*(-\>|→|=\>)}:+\=${${MATCH#*(-\>|→|=\>)}//((#s)[[:space:]]##|[[:space:]]##(#e))}}}) 
	(( ${#reply} )) && return 0 || return 1
}
.zinit-submit-turbo () {
	local tpe="$1" mode="$2" opt_uspl2="$3" opt_plugin="$4" 
	ICE[wait]="${ICE[wait]%%.[0-9]##}" 
	ZINIT[WAIT_IDX]=$(( ${ZINIT[WAIT_IDX]:-0} + 1 )) 
	ZINIT[WAIT_ICE_${ZINIT[WAIT_IDX]}]="${(j: :)${(qkv)ICE[@]}}" 
	ZINIT[fts-${ICE[subscribe]}]="${ICE[subscribe]:+$EPOCHSECONDS}" 
	[[ $tpe = s* ]] && local id="${${opt_plugin:+$opt_plugin}:-$opt_uspl2}"  || local id="${${opt_plugin:+$opt_uspl2${${opt_uspl2:#%*}:+/}$opt_plugin}:-$opt_uspl2}" 
	if [[ ${${ICE[wait]}%%[^0-9]([^0-9]|)([^0-9]|)([^0-9]|)} = (\!|.|)<-> ]]
	then
		ZINIT_TASKS+=("$EPOCHSECONDS+${${ICE[wait]#(\!|.)}%%[^0-9]([^0-9]|)([^0-9]|)([^0-9]|)}+${${${(M)ICE[wait]%a}:+1}:-${${${(M)ICE[wait]%b}:+2}:-${${${(M)ICE[wait]%c}:+3}:-1}}} $tpe ${ZINIT[WAIT_IDX]} ${mode:-_} ${(q)id} ${opt_plugin:+${(q)opt_uspl2}}") 
	elif [[ -n ${ICE[wait]}${ICE[load]}${ICE[unload]}${ICE[subscribe]} ]]
	then
		ZINIT_TASKS+=("${${ICE[wait]:+0}:-1}+0+1 $tpe ${ZINIT[WAIT_IDX]} ${mode:-_} ${(q)id} ${opt_plugin:+${(q)opt_uspl2}}") 
	fi
}
.zinit-tmp-subst-off () {
	builtin setopt localoptions noerrreturn noerrexit extendedglob warncreateglobal typesetsilent noshortloops unset noaliases
	local mode="$1" 
	[[ ${ZINIT[TMP_SUBST]} = inactive || ${ZINIT[TMP_SUBST]} != $mode ]] && return 0
	ZINIT[TMP_SUBST]=inactive 
	if [[ $mode != compdef ]]
	then
		(( ${+ZINIT[bkp-autoload]} )) && functions[autoload]="${ZINIT[bkp-autoload]}"  || unfunction autoload
	fi
	(( ${+ZINIT[bkp-compdef]} )) && functions[compdef]="${ZINIT[bkp-compdef]}"  || unfunction compdef
	(( ${+ZINIT[bkp-source]} )) && functions[source]="${ZINIT[bkp-source]}"  || unfunction source 2> /dev/null
	(( ${+ZINIT[bkp-.]} )) && functions[.]="${ZINIT[bkp-.]}"  || unfunction . 2> /dev/null
	[[ ( $mode = light && ${+ICE[trackbinds]} -eq 0 ) || $mode = compdef ]] && return 0
	(( ${+ZINIT[bkp-bindkey]} )) && functions[bindkey]="${ZINIT[bkp-bindkey]}"  || unfunction bindkey
	[[ $mode = light-b || ( $mode = light && ${+ICE[trackbinds]} -eq 1 ) ]] && return 0
	(( ${+ZINIT[bkp-zstyle]} )) && functions[zstyle]="${ZINIT[bkp-zstyle]}"  || unfunction zstyle
	(( ${+ZINIT[bkp-alias]} )) && functions[alias]="${ZINIT[bkp-alias]}"  || unfunction alias
	(( ${+ZINIT[bkp-zle]} )) && functions[zle]="${ZINIT[bkp-zle]}"  || unfunction zle
	return 0
}
.zinit-tmp-subst-on () {
	local mode="$1" 
	[[ ${ZINIT[TMP_SUBST]} != inactive ]] && builtin return 0
	ZINIT[TMP_SUBST]="$mode" 
	builtin unset "ZINIT[bkp-autoload]" "ZINIT[bkp-compdef]"
	if [[ $mode != compdef ]]
	then
		(( ${+functions[autoload]} )) && ZINIT[bkp-autoload]="${functions[autoload]}" 
		functions[autoload]=':zinit-tmp-subst-autoload "$@";' 
	fi
	(( ${+functions[compdef]} )) && ZINIT[bkp-compdef]="${functions[compdef]}" 
	functions[compdef]=':zinit-tmp-subst-compdef "$@";' 
	if [[ -n ${ICE[subst]} ]]
	then
		(( ${+functions[source]} )) && ZINIT[bkp-source]="${functions[source]}" 
		(( ${+functions[.]} )) && ZINIT[bkp-.]="${functions[.]}" 
		(( ${+functions[.zinit-service]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-additional.zsh"
		functions[source]=':zinit-tmp-subst-source "$@";' 
		functions[.]=':zinit-tmp-subst-source "$@";' 
	fi
	[[ ( $mode = light && ${+ICE[trackbinds]} -eq 0 ) || $mode = compdef ]] && return 0
	builtin unset "ZINIT[bkp-bindkey]" "ZINIT[bkp-zstyle]" "ZINIT[bkp-alias]" "ZINIT[bkp-zle]"
	(( ${+functions[bindkey]} )) && ZINIT[bkp-bindkey]="${functions[bindkey]}" 
	functions[bindkey]=':zinit-tmp-subst-bindkey "$@";' 
	[[ $mode = light-b || ( $mode = light && ${+ICE[trackbinds]} -eq 1 ) ]] && return 0
	(( ${+functions[zstyle]} )) && ZINIT[bkp-zstyle]="${functions[zstyle]}" 
	functions[zstyle]=':zinit-tmp-subst-zstyle "$@";' 
	(( ${+functions[alias]} )) && ZINIT[bkp-alias]="${functions[alias]}" 
	functions[alias]=':zinit-tmp-subst-alias "$@";' 
	(( ${+functions[zle]} )) && ZINIT[bkp-zle]="${functions[zle]}" 
	functions[zle]=':zinit-tmp-subst-zle "$@";' 
	builtin return 0
}
.zinit-util-shands-path () {
	builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}
	builtin setopt extendedglob typesetsilent noshortloops rcquotes ${${${+REPLY}:#0}:+warncreateglobal}
	local -A map
	map=(\~ %HOME $HOME %HOME $ZINIT[SNIPPETS_DIR] %SNIPPETS $ZINIT[PLUGINS_DIR] %PLUGINS "$ZPFX" %ZPFX HOME %HOME SNIPPETS %SNIPPETS PLUGINS %PLUGINS "" "") 
	REPLY=${${1/(#b)(#s)(%|)(${(~j:|:)${(@k)map:#$HOME}}|$HOME|)/$map[$match[2]]}} 
	return 0
}
/fshdbg () {
	print -r -- "$@" >>| /tmp/reply
}
:zinit-reload-and-run () {
	local fpath_prefix="$1" autoload_opts="$2" func="$3" 
	shift 3
	unfunction -- "$func"
	local -a ___fpath
	___fpath=(${fpath[@]}) 
	local -a +h fpath
	[[ $FPATH != *${${(@0)fpath_prefix}[1]}* ]] && fpath=(${(@0)fpath_prefix} ${___fpath[@]}) 
	builtin autoload ${(s: :)autoload_opts} -- "$func"
	"$func" "$@"
}
:zinit-tmp-subst-alias () {
	builtin setopt localoptions noerrreturn noerrexit extendedglob warncreateglobal typesetsilent noshortloops unset
	.zinit-add-report "${ZINIT[CUR_USPL2]}" "Alias $*"
	typeset -a pos
	pos=("$@") 
	local -a opts
	zparseopts -a opts -D ${(s::):-gs}
	local a quoted tmp
	for a in "$@"
	do
		local aname="${a%%[=]*}" 
		local avalue="${a#*=}" 
		(( ${+aliases[$aname]} )) && .zinit-add-report "${ZINIT[CUR_USPL2]}" "Warning: redefining alias \`${aname}', previous value: ${aliases[$aname]}"
		local bname=${(q)aliases[$aname]} 
		aname="${(q)aname}" 
		if (( ${+opts[(r)-s]} ))
		then
			tmp=-s 
			tmp="${(q)tmp}" 
			quoted="$aname $bname $tmp" 
		elif (( ${+opts[(r)-g]} ))
		then
			tmp=-g 
			tmp="${(q)tmp}" 
			quoted="$aname $bname $tmp" 
		else
			quoted="$aname $bname" 
		fi
		quoted="${(q)quoted}" 
		[[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[ALIASES__${ZINIT[CUR_USPL2]}]+="$quoted " 
		[[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[ALIASES___dtrace/_dtrace]+="$quoted " 
	done
	builtin alias "${pos[@]}"
	return $?
}
:zinit-tmp-subst-autoload () {
	builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}
	builtin setopt extendedglob warncreateglobal typesetsilent rcquotes
	local -a opts opts2 custom reply
	local func
	zparseopts -D -E -M -a opts ${(s::):-RTUXdkmrtWzwC} I+=opts2 S+:=custom
	builtin set -- ${@:#--}
	.zinit-any-to-user-plugin $ZINIT[CUR_USPL2]
	[[ $reply[1] = % ]] && local PLUGIN_DIR="$reply[2]"  || local PLUGIN_DIR="$ZINIT[PLUGINS_DIR]/${reply[1]:+$reply[1]---}${reply[2]//\//---}" 
	local -a fpath_elements
	fpath_elements=(${fpath[(r)$PLUGIN_DIR/*]}) 
	[[ -d $PLUGIN_DIR/functions ]] && fpath_elements+=("$PLUGIN_DIR"/functions) 
	if (( ${+opts[(r)-X]} ))
	then
		.zinit-add-report "${ZINIT[CUR_USPL2]}" "Warning: Failed autoload ${(j: :)opts[@]} $*"
		+zi-log -u2 "{error}builtin autoload required for {obj}${(j: :)opts[@]}{error} option(s)"
		return 1
	fi
	if (( ${+opts[(r)-w]} ))
	then
		.zinit-add-report "${ZINIT[CUR_USPL2]}" "-w-Autoload ${(j: :)opts[@]} ${(j: :)@}"
		fpath+=($PLUGIN_DIR) 
		builtin autoload ${opts[@]} "$@"
		return $?
	fi
	if [[ -n ${(M)@:#+X} ]]
	then
		.zinit-add-report "${ZINIT[CUR_USPL2]}" "Autoload +X ${opts:+${(j: :)opts[@]} }${(j: :)${@:#+X}}"
		local +h FPATH=$PLUGINS_DIR${fpath_elements:+:${(j.:.)fpath_elements[@]}}:$FPATH 
		local +h -a fpath
		fpath=($PLUGIN_DIR $fpath_elements $fpath) 
		builtin autoload +X ${opts[@]} "${@:#+X}"
		return $?
	fi
	for func
	do
		.zinit-add-report "${ZINIT[CUR_USPL2]}" "Autoload $func${opts:+ with options ${(j: :)opts[@]}}"
	done
	integer count retval
	for func
	do
		if (( ${+functions[$func]} != 1 ))
		then
			builtin setopt noaliases
			if [[ $func == /* ]] && is-at-least 5.4
			then
				builtin autoload ${opts[@]} $func
				return $?
			elif [[ $func == /* ]]
			then
				if [[ $ZINIT[MUTE_WARNINGS] != (1|true|on|yes) && -z $ZINIT[WARN_SHOWN_FOR_$ZINIT[CUR_USPL2]] ]]
				then
					+zi-log "{u-warn}Warning{b-warn}: {rst}the plugin {pid}$ZINIT[CUR_USPL2]" "{rst}is using autoload functions specified by their absolute path," "which is not supported by this Zsh version ({↔} {version}$ZSH_VERSION{rst}," "required is Zsh >= {version}5.4{rst})." "{nl}A fallback mechanism has been applied, which works well only" "for functions in the plugin {u}{slight}main{rst} directory." "{nl}(To mute this message, set" "{var}\$ZINIT[MUTE_WARNINGS]{rst} to a truth value.)"
					ZINIT[WARN_SHOWN_FOR_$ZINIT[CUR_USPL2]]=1 
				fi
				func=$func:t 
			fi
			if [[ ${ZINIT[NEW_AUTOLOAD]} = 2 ]]
			then
				builtin autoload ${opts[@]} "$PLUGIN_DIR/$func"
				retval=$? 
			elif [[ ${ZINIT[NEW_AUTOLOAD]} = 1 ]]
			then
				if (( ${+opts[(r)-C]} ))
				then
					local pth nl=$'\n' sel="" 
					for pth in $PLUGIN_DIR $fpath_elements $fpath
					do
						[[ -f $pth/$func ]] && {
							sel=$pth 
							break
						}
					done
					if [[ -z $sel ]]
					then
						+zi-log '{u-warn}zinit{b-warn}:{error} Couldn''t find autoload function{ehi}:' "{apo}\`{file}${func}{apo}\`{error} anywhere in {var}\$fpath{error}."
						retval=1 
					else
						eval "function ${(q)${custom[++count*2]}:-$func} {
                            local body=\"\$(<${(qqq)sel}/${(qqq)func})\" body2
                            () { setopt localoptions extendedglob
                                 body2=\"\${body##[[:space:]]#${func}[[:blank:]]#\(\)[[:space:]]#\{}\"
                                 [[ \$body2 != \$body ]] &&                                     body2=\"\${body2%\}[[:space:]]#([$nl]#([[:blank:]]#\#[^$nl]#((#e)|[$nl]))#)#}\"
                            }

                            functions[${${(q)custom[count*2]}:-$func}]=\"\$body2\"
                            ${(q)${custom[count*2]}:-$func} \"\$@\"
                        }"
						retval=$? 
					fi
				else
					functions[$func]="
                        local -a fpath
                        fpath=( ${(qqq)PLUGIN_DIR} ${(qqq@)fpath_elements} ${(qqq@)fpath} )
                        builtin autoload -X ${(j: :)${(q-)opts[@]}}
                    " 
					retval=$? 
				fi
			else
				eval "function ${(q)func} {
                    :zinit-reload-and-run ${(qqq)PLUGIN_DIR}"$'\0'"${(pj,\0,)${(qqq)fpath_elements[@]}} ${(qq)opts[*]} ${(q)func} "'"$@"
                }'
				retval=$? 
			fi
			(( ZINIT[ALIASES_OPT] )) && builtin setopt aliases
		fi
		if (( ${+opts2[(r)-I]} ))
		then
			${custom[count*2]:-$func}
			retval=$? 
		fi
	done
	return $retval
}
:zinit-tmp-subst-bindkey () {
	builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}
	builtin setopt extendedglob warncreateglobal typesetsilent noshortloops
	is-at-least 5.3 && .zinit-add-report "${ZINIT[CUR_USPL2]}" "Bindkey ${(j: :)${(q+)@}}" || .zinit-add-report "${ZINIT[CUR_USPL2]}" "Bindkey ${(j: :)${(q)@}}"
	typeset -a pos
	pos=("$@") 
	local -A opts
	zparseopts -A opts -D ${(s::):-lLdDAmrsevaR} M: N:
	if (( ${#opts} == 0 ||
        ( ${#opts} == 1 && ${+opts[-M]} ) ||
        ( ${#opts} == 1 && ${+opts[-R]} ) ||
        ( ${#opts} == 1 && ${+opts[-s]} ) ||
        ( ${#opts} <= 2 && ${+opts[-M]} && ${+opts[-s]} ) ||
        ( ${#opts} <= 2 && ${+opts[-M]} && ${+opts[-R]} )
    ))
	then
		local string="${(q)1}" widget="${(q)2}" 
		local quoted
		if [[ -n ${ICE[bindmap]} && ${ZINIT_CUR_BIND_MAP[empty]} -eq 1 ]]
		then
			local -a pairs
			pairs=("${(@s,;,)ICE[bindmap]}") 
			if [[ -n ${(M)pairs:#*\\(#e)} ]]
			then
				local prev
				pairs=(${pairs[@]//(#b)((*)\\(#e)|(*))/${match[3]:+${prev:+$prev\;}}${match[3]}${${prev::=${match[2]:+${prev:+$prev\;}}${match[2]}}:+}}) 
			fi
			pairs=("${(@)${(@)${(@s:->:)pairs}##[[:space:]]##}%%[[:space:]]##}") 
			ZINIT_CUR_BIND_MAP=(empty 0) 
			(( ${#pairs} > 1 && ${#pairs[@]} % 2 == 0 )) && ZINIT_CUR_BIND_MAP+=("${pairs[@]}") 
		fi
		local bmap_val="${ZINIT_CUR_BIND_MAP[${1}]}" 
		if (( !ZINIT_CUR_BIND_MAP[empty] ))
		then
			[[ -z $bmap_val ]] && bmap_val="${ZINIT_CUR_BIND_MAP[${(qqq)1}]}" 
			[[ -z $bmap_val ]] && bmap_val="${ZINIT_CUR_BIND_MAP[${(qqq)${(Q)1}}]}" 
			[[ -z $bmap_val ]] && {
				bmap_val="${ZINIT_CUR_BIND_MAP[!${(qqq)1}]}" 
				integer val=1 
			}
			[[ -z $bmap_val ]] && bmap_val="${ZINIT_CUR_BIND_MAP[!${(qqq)${(Q)1}}]}" 
		fi
		if [[ -n $bmap_val ]]
		then
			string="${(q)bmap_val}" 
			if (( val ))
			then
				[[ ${pos[1]} = "-M" ]] && pos[4]="$bmap_val"  || pos[2]="$bmap_val" 
			else
				[[ ${pos[1]} = "-M" ]] && pos[3]="${(Q)bmap_val}"  || pos[1]="${(Q)bmap_val}" 
			fi
			.zinit-add-report "${ZINIT[CUR_USPL2]}" ":::Bindkey: combination <$1> changed to <$bmap_val>${${(M)bmap_val:#hold}:+, i.e. ${ZINIT[col-error]}unmapped${ZINIT[col-rst]}}"
			((1))
		elif [[ ( -n ${bmap_val::=${ZINIT_CUR_BIND_MAP[UPAR]}} && -n ${${ZINIT[UPAR]}[(r);:${(q)1};:]} ) || ( -n ${bmap_val::=${ZINIT_CUR_BIND_MAP[DOWNAR]}} && -n ${${ZINIT[DOWNAR]}[(r);:${(q)1};:]} ) || ( -n ${bmap_val::=${ZINIT_CUR_BIND_MAP[RIGHTAR]}} && -n ${${ZINIT[RIGHTAR]}[(r);:${(q)1};:]} ) || ( -n ${bmap_val::=${ZINIT_CUR_BIND_MAP[LEFTAR]}} && -n ${${ZINIT[LEFTAR]}[(r);:${(q)1};:]} ) ]]
		then
			string="${(q)bmap_val}" 
			if (( val ))
			then
				[[ ${pos[1]} = "-M" ]] && pos[4]="$bmap_val"  || pos[2]="$bmap_val" 
			else
				[[ ${pos[1]} = "-M" ]] && pos[3]="${(Q)bmap_val}"  || pos[1]="${(Q)bmap_val}" 
			fi
			.zinit-add-report "${ZINIT[CUR_USPL2]}" ":::Bindkey: combination <$1> recognized as cursor-key and changed to <${bmap_val}>${${(M)bmap_val:#hold}:+, i.e. ${ZINIT[col-error]}unmapped${ZINIT[col-rst]}}"
		fi
		[[ $bmap_val = hold ]] && return 0
		local prev="${(q)${(s: :)$(builtin bindkey ${(Q)string})}[-1]#undefined-key}" 
		if (( ${+opts[-M]} ))
		then
			local Mopt=-M 
			local Marg="${opts[-M]}" 
			Mopt="${(q)Mopt}" 
			Marg="${(q)Marg}" 
			quoted="$string $widget $prev $Mopt $Marg" 
		else
			quoted="$string $widget $prev" 
		fi
		if (( ${+opts[-R]} ))
		then
			local Ropt=-R 
			Ropt="${(q)Ropt}" 
			if (( ${+opts[-M]} ))
			then
				quoted="$quoted $Ropt" 
			else
				local space=_ 
				space="${(q)space}" 
				quoted="$quoted $space $space $Ropt" 
			fi
		fi
		quoted="${(q)quoted}" 
		[[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[BINDKEYS__${ZINIT[CUR_USPL2]}]+="$quoted " 
		[[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[BINDKEYS___dtrace/_dtrace]+="$quoted " 
	else
		if [[ ${#opts} -eq 1 && ${+opts[-A]} = 1 && ${#pos} = 3 && ${pos[-1]} = main && ${pos[-2]} != -A ]]
		then
			(( ZINIT[BINDKEY_MAIN_IDX] = ${ZINIT[BINDKEY_MAIN_IDX]:-0} + 1 ))
			local pname="${ZINIT[CUR_PLUGIN]:-_dtrace}" 
			local name="${(q)pname}-main-${ZINIT[BINDKEY_MAIN_IDX]}" 
			builtin bindkey -N "$name" main
			local keys=_ widget=_ prev= optA=-A mapname="${name}" optR=_ 
			local quoted="${(q)keys} ${(q)widget} ${(q)prev} ${(q)optA} ${(q)mapname} ${(q)optR}" 
			quoted="${(q)quoted}" 
			[[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[BINDKEYS__${ZINIT[CUR_USPL2]}]+="$quoted " 
			[[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[BINDKEYS___dtrace/_dtrace]+="$quoted " 
			.zinit-add-report "${ZINIT[CUR_USPL2]}" "Warning: keymap \`main' copied to \`${name}' because of \`${pos[-2]}' substitution"
		elif [[ ${#opts} -eq 1 && ${+opts[-N]} = 1 ]]
		then
			local Nopt=-N 
			local Narg="${opts[-N]}" 
			local keys=_ widget=_ prev= optN=-N mapname="${Narg}" optR=_ 
			local quoted="${(q)keys} ${(q)widget} ${(q)prev} ${(q)optN} ${(q)mapname} ${(q)optR}" 
			quoted="${(q)quoted}" 
			[[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[BINDKEYS__${ZINIT[CUR_USPL2]}]+="$quoted " 
			[[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[BINDKEYS___dtrace/_dtrace]+="$quoted " 
		else
			.zinit-add-report "${ZINIT[CUR_USPL2]}" "Warning: last bindkey used non-typical options: ${(kv)opts[*]}"
		fi
	fi
	builtin bindkey "${pos[@]}"
	return $?
}
:zinit-tmp-subst-compdef () {
	builtin setopt localoptions noerrreturn noerrexit extendedglob warncreateglobal typesetsilent noshortloops unset
	.zinit-add-report "${ZINIT[CUR_USPL2]}" "Saving \`compdef $*' for replay"
	ZINIT_COMPDEF_REPLAY+=("${(j: :)${(q)@}}") 
	return 0
}
:zinit-tmp-subst-zle () {
	builtin setopt localoptions noerrreturn noerrexit extendedglob warncreateglobal typesetsilent noshortloops unset
	.zinit-add-report "${ZINIT[CUR_USPL2]}" "Zle $*"
	typeset -a pos
	pos=("$@") 
	builtin set -- "${@:#--}"
	if [[ ( $1 = -N && ( $# = 2 || $# = 3 ) ) || ( $1 = -C && $# = 4 ) ]]
	then
		if [[ ${ZINIT_ZLE_HOOKS_LIST[$2]} = 1 ]]
		then
			local quoted="$2" 
			quoted="${(q)quoted}" 
			[[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[WIDGETS_DELETE__${ZINIT[CUR_USPL2]}]+="$quoted " 
			[[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[WIDGETS_DELETE___dtrace/_dtrace]+="$quoted " 
		elif (( ${+widgets[$2]} ))
		then
			local widname="$2" targetfun="${${${(M)1:#-C}:+$4}:-$3}" 
			local completion_widget="${${(M)1:#-C}:+$3}" 
			local saved_widcontents="${widgets[$widname]}" 
			widname="${(q)widname}" 
			completion_widget="${(q)completion_widget}" 
			targetfun="${(q)targetfun}" 
			saved_widcontents="${(q)saved_widcontents}" 
			local quoted="$1 $widname $completion_widget $targetfun $saved_widcontents" 
			quoted="${(q)quoted}" 
			[[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[WIDGETS_SAVED__${ZINIT[CUR_USPL2]}]+="$quoted " 
			[[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[WIDGETS_SAVED___dtrace/_dtrace]+="$quoted " 
		else
			.zinit-add-report "${ZINIT[CUR_USPL2]}" "Note: a new widget created via zle -N: \`$2'"
			local quoted="$2" 
			quoted="${(q)quoted}" 
			[[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[WIDGETS_DELETE__${ZINIT[CUR_USPL2]}]+="$quoted " 
			[[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[WIDGETS_DELETE___dtrace/_dtrace]+="$quoted " 
		fi
	fi
	builtin zle "${pos[@]}"
	return $?
}
:zinit-tmp-subst-zstyle () {
	builtin setopt localoptions noerrreturn noerrexit extendedglob nowarncreateglobal typesetsilent noshortloops unset
	.zinit-add-report "${ZINIT[CUR_USPL2]}" "Zstyle $*"
	typeset -a pos
	pos=("$@") 
	local -a opts
	zparseopts -a opts -D ${(s::):-eLdgabsTtm}
	if [[ ${#opts} -eq 0 || ( ${#opts} -eq 1 && ${+opts[(r)-e]} = 1 ) ]]
	then
		local pattern="${(q)1}" style="${(q)2}" 
		local ps="$pattern $style" 
		ps="${(q)ps}" 
		[[ -n ${ZINIT[CUR_USPL2]} ]] && ZINIT[ZSTYLES__${ZINIT[CUR_USPL2]}]+="$ps " 
		[[ ${ZINIT[DTRACE]} = 1 ]] && ZINIT[ZSTYLES___dtrace/_dtrace]+=$ps 
	else
		if [[ ! ${#opts[@]} = 1 && ( ${+opts[(r)-s]} = 1 || ${+opts[(r)-b]} = 1 || ${+opts[(r)-a]} = 1 || ${+opts[(r)-t]} = 1 || ${+opts[(r)-T]} = 1 || ${+opts[(r)-m]} = 1 ) ]]
		then
			.zinit-add-report "${ZINIT[CUR_USPL2]}" "Warning: last zstyle used non-typical options: ${opts[*]}"
		fi
	fi
	builtin zstyle "${pos[@]}"
	return $?
}
@autoload () {
	:zinit-tmp-subst-autoload -Uz ${(s: :)${${(j: :)${@#\!}}//(#b)((*)(->|=>|→)(*)|(*))/${match[2]:+$match[2]       -S $match[4]}${match[5]:+${match[5]}       -S ${match[5]}}}} ${${${(@M)${@#\!}:#*(->|=>|→)*}}:+-C} ${${@#\!}:+-C}
}
@zinit-register-annex () {
	builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}
	builtin setopt nobanghist
	local name="$1" type="$2" handler="$3" helphandler="$4" icemods="$5" key="z-annex ${(q)2}" 
	ZINIT_EXTS[seqno]=$(( ${ZINIT_EXTS[seqno]:-0} + 1 )) 
	ZINIT_EXTS[$key${${(M)type#hook:}:+ ${ZINIT_EXTS[seqno]}}]="${ZINIT_EXTS[seqno]} z-annex-data: ${(q)name} ${(q)type} ${(q)handler} ${(q)helphandler} ${(q)icemods}" 
	() {
		builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}
		builtin setopt nobanghist
		integer index="${type##[%a-zA-Z:_!-]##}" 
		ZINIT_EXTS[ice-mods]="${ZINIT_EXTS[ice-mods]}${icemods:+|}${(j:|:)${(@)${(@s:|:)icemods}/(#b)(#s)(?)/$index-$match[1]}}" 
	}
}
@zinit-register-hook () {
	builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}
	builtin setopt extendedglob nobanghist noshortloops typesetsilent warncreateglobal
	local name="$1" type="$2" handler="$3" icemods="$4" key="zinit ${(q)2}" 
	ZINIT_EXTS2[seqno]=$(( ${ZINIT_EXTS2[seqno]:-0} + 1 )) 
	ZINIT_EXTS2[$key${${(M)type#hook:}:+ ${ZINIT_EXTS2[seqno]}}]="${ZINIT_EXTS2[seqno]} z-annex-data: ${(q)name} ${(q)type} ${(q)handler} '' ${(q)icemods}" 
	ZINIT_EXTS2[ice-mods]="${ZINIT_EXTS2[ice-mods]}${icemods:+|}$icemods" 
}
@zinit-scheduler () {
	integer ___ret="${${ZINIT[lro-data]%:*}##*:}" 
	[[ $1 = following ]] && sched +1 'ZINIT[lro-data]="$_:$?:${options[printexitvalue]}"; @zinit-scheduler following "${ZINIT[lro-data]%:*:*}"'
	[[ -n $1 && $1 != (following*|burst) ]] && {
		local THEFD="$1" 
		zle -F "$THEFD"
		exec {THEFD}<&-
	}
	[[ $1 = burst ]] && local -h EPOCHSECONDS=$(( EPOCHSECONDS+10000 )) 
	ZINIT[START_TIME]="${ZINIT[START_TIME]:-$EPOCHREALTIME}" 
	integer ___t=EPOCHSECONDS ___i correct 
	local -a match mbegin mend reply
	local MATCH REPLY AFD
	integer MBEGIN MEND
	[[ -o ksharrays ]] && correct=1 
	if [[ -n $1 ]]
	then
		if [[ ${#ZINIT_RUN} -le 1 || $1 = following ]]
		then
			() {
				builtin emulate -L zsh ${=${options[xtrace]:#off}:+-o xtrace}
				builtin setopt extendedglob
				integer ___idx1 ___idx2
				local ___ar2 ___ar3 ___ar4 ___ar5
				for ((___idx1 = 0; ___idx1 <= 4; ___idx1 ++ )) do
					for ((___idx2 = 1; ___idx2 <= (___idx >= 4 ? 1 : 3); ___idx2 ++ )) do
						___i=2 
						ZINIT_TASKS=(${ZINIT_TASKS[@]/(#b)([0-9]##)+([0-9]##)+([1-3])(*)/${ZINIT_TASKS[
                        $(( (___ar2=${match[2]}+1) ? (
                            (___ar3=${(M)match[3]%[1-3]}) ? (
                            (___ar4=___idx1+1) ? (
                            (___ar5=___idx2) ? (
                (${match[1]}+${match[2]}) <= $___t ?
                zinit_scheduler_add(___i++) : ___i++ )
                            : 1 )
                            : 1 )
                            : 1 )
                            : 1  ))]}}) 
						ZINIT_TASKS=("<no-data>" ${ZINIT_TASKS[@]:#<no-data>}) 
					done
				done
			}
		fi
	else
		add-zsh-hook -d -- precmd @zinit-scheduler
		add-zsh-hook -- chpwd @zinit-scheduler
		() {
			builtin emulate -L zsh ${=${options[xtrace]:#off}:+-o xtrace}
			builtin setopt extendedglob
			ZINIT_TASKS=(${ZINIT_TASKS[@]/(#b)([0-9]##)(*)/$(( ${match[1]} <= 1 ? ${match[1]} : ___t ))${match[2]}}) 
		}
		sched +1 'ZINIT[lro-data]="$_:$?:${options[printexitvalue]}"; @zinit-scheduler following ${ZINIT[lro-data]%:*:*}'
		AFD=13371337 
		exec {AFD}< <(LANG=C command sleep 0.002; builtin print run;)
		command true
		zle -F "$AFD" @zinit-scheduler
	fi
	local ___task ___idx=0 ___count=0 ___idx2 
	for ___task in "${ZINIT_RUN[@]}"
	do
		.zinit-run-task 1 "${(@z)___task}" && ZINIT_TASKS+=("$___task") 
		if [[ $(( ++___idx, ___count += ${${REPLY:+1}:-0} )) -gt 0 && $1 != burst ]]
		then
			AFD=13371337 
			exec {AFD}< <(LANG=C command sleep 0.0002; builtin print run;)
			command true
			zle -F "$AFD" @zinit-scheduler
			break
		fi
	done
	for ((___idx2=1; ___idx2 <= ___idx; ++ ___idx2 )) do
		.zinit-run-task 2 "${(@z)ZINIT_RUN[___idx2-correct]}"
	done
	for ((___idx2=1; ___idx2 <= ___idx; ++ ___idx2 )) do
		.zinit-run-task 3 "${(@z)ZINIT_RUN[___idx2-correct]}"
	done
	ZINIT_RUN[1-correct,___idx-correct]=() 
	[[ ${ZINIT[lro-data]##*:} = on ]] && return 0 || return ___ret
}
@zinit-substitute () {
	builtin emulate -LR zsh ${=${options[xtrace]:#off}:+-o xtrace}
	builtin setopt extendedglob warncreateglobal typesetsilent noshortloops
	local -A ___subst_map
	___subst_map=("%ID%" "${id_as_clean:-$id_as}" "%USER%" "$user" "%PLUGIN%" "${plugin:-$save_url}" "%URL%" "${save_url:-${user:+$user/}$plugin}" "%DIR%" "${local_path:-$local_dir${dirname:+/$dirname}}" '$ZPFX' "$ZPFX" '${ZPFX}' "$ZPFX" '%OS%' "${OSTYPE%(-gnu|[0-9]##)}" '%MACH%' "$MACHTYPE" '%CPU%' "$CPUTYPE" '%VENDOR%' "$VENDOR" '%HOST%' "$HOST" '%UID%' "$UID" '%GID%' "$GID") 
	if [[ -n ${ICE[param]} && ${ZINIT[SUBST_DONE_FOR]} != ${ICE[param]} ]]
	then
		ZINIT[SUBST_DONE_FOR]=${ICE[param]} 
		ZINIT[PARAM_SUBST]= 
		local -a ___params
		___params=(${(s.;.)ICE[param]}) 
		local ___param ___from ___to
		for ___param in ${___params[@]}
		do
			local ___from=${${___param%%([[:space:]]|)(->|→)*}##[[:space:]]##} ___to=${${___param#*(->|→)([[:space:]]|)}%[[:space:]]} 
			___from=${___from//((#s)[[:space:]]##|[[:space:]]##(#e))/} 
			___to=${___to//((#s)[[:space:]]##|[[:space:]]##(#e))/} 
			ZINIT[PARAM_SUBST]+="%${(q)___from}% ${(q)___to} " 
		done
	fi
	local -a ___add
	___add=("${ICE[param]:+${(@Q)${(@z)ZINIT[PARAM_SUBST]}}}") 
	(( ${#___add} % 2 == 0 )) && ___subst_map+=("${___add[@]}") 
	local ___var_name
	for ___var_name
	do
		local ___value=${(P)___var_name} 
		___value=${___value//(#m)(%[a-zA-Z0-9]##%|\$ZPFX|\$\{ZPFX\})/${___subst_map[$MATCH]}} 
		: ${(P)___var_name::=$___value}
	done
}
@zsh-plugin-run-on-unload () {
	ICE[ps-on-unload]="${(j.; .)@}" 
	.zinit-pack-ice "$id_as" ""
}
@zsh-plugin-run-on-update () {
	ICE[ps-on-update]="${(j.; .)@}" 
	.zinit-pack-ice "$id_as" ""
}
add-zle-hook-widget () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions") 
	builtin autoload -X -U
}
add-zsh-hook () {
	emulate -L zsh
	local -a hooktypes
	hooktypes=(chpwd precmd preexec periodic zshaddhistory zshexit zsh_directory_name) 
	local usage="Usage: add-zsh-hook hook function\nValid hooks are:\n  $hooktypes" 
	local opt
	local -a autoopts
	integer del list help
	while getopts "dDhLUzk" opt
	do
		case $opt in
			(d) del=1  ;;
			(D) del=2  ;;
			(h) help=1  ;;
			(L) list=1  ;;
			([Uzk]) autoopts+=(-$opt)  ;;
			(*) return 1 ;;
		esac
	done
	shift $(( OPTIND - 1 ))
	if (( list ))
	then
		typeset -mp "(${1:-${(@j:|:)hooktypes}})_functions"
		return $?
	elif (( help || $# != 2 || ${hooktypes[(I)$1]} == 0 ))
	then
		print -u$(( 2 - help )) $usage
		return $(( 1 - help ))
	fi
	local hook="${1}_functions" 
	local fn="$2" 
	if (( del ))
	then
		if (( ${(P)+hook} ))
		then
			if (( del == 2 ))
			then
				set -A $hook ${(P)hook:#${~fn}}
			else
				set -A $hook ${(P)hook:#$fn}
			fi
			if (( ! ${(P)#hook} ))
			then
				unset $hook
			fi
		fi
	else
		if (( ${(P)+hook} ))
		then
			if (( ${${(P)hook}[(I)$fn]} == 0 ))
			then
				typeset -ga $hook
				set -A $hook ${(P)hook} $fn
			fi
		else
			typeset -ga $hook
			set -A $hook $fn
		fi
		autoload $autoopts -- $fn
	fi
}
build-fzf-tab-module () {
	{
		pushd -q $FZF_TAB_HOME/modules
		if -ftb-build-module $@
		then
			print -P "%F{green}%BThe module has been built successfully. Please restart zsh to apply it.%f%b"
		else
			print -P -u2 "%F{red}%BThe module building has failed. See the output above for details.%f%b"
			return 1
		fi
	} always {
		popd -q
	}
}
cli_help () {
	if [[ -z "$1" ]]
	then
		echo "Usage: cli_help <your question about CLI commands>"
		return 1
	fi
	cmd=$(claude --system-prompt "You are a command-line expert specializing in Bash and ZSH. When the user asks how to perform a task, respond with a single-line CLI command that solves it. Only output the command itself, in plain text—no code blocks, no commentary, no syntax highlighting, no shell output, and no functions or aliases unless explicitly requested. Output must be suitable for direct copy-paste into a terminal." -p "I want a shell command to: $1") 
	echo "Suggested command:"
	echo "$cmd"
	echo -n "Execute? [y/N]: "
	read confirm
	if [[ "$confirm" == [Yy] ]]
	then
		bash -c "$cmd"
	fi
}
colors () {
	emulate -L zsh
	typeset -Ag color colour
	color=(00 none 01 bold 02 faint 22 normal 03 italic 23 no-italic 04 underline 24 no-underline 05 blink 25 no-blink 07 reverse 27 no-reverse 08 conceal 28 no-conceal 30 black 40 bg-black 31 red 41 bg-red 32 green 42 bg-green 33 yellow 43 bg-yellow 34 blue 44 bg-blue 35 magenta 45 bg-magenta 36 cyan 46 bg-cyan 37 white 47 bg-white 39 default 49 bg-default) 
	local k
	for k in ${(k)color}
	do
		color[${color[$k]}]=$k 
	done
	for k in ${color[(I)3?]}
	do
		color[fg-${color[$k]}]=$k 
	done
	for k in grey gray
	do
		color[$k]=${color[black]} 
		color[fg-$k]=${color[$k]} 
		color[bg-$k]=${color[bg-black]} 
	done
	colour=(${(kv)color}) 
	local lc=$'\e[' rc=m 
	typeset -Hg reset_color bold_color
	reset_color="$lc${color[none]}$rc" 
	bold_color="$lc${color[bold]}$rc" 
	typeset -AHg fg fg_bold fg_no_bold
	for k in ${(k)color[(I)fg-*]}
	do
		fg[${k#fg-}]="$lc${color[$k]}$rc" 
		fg_bold[${k#fg-}]="$lc${color[bold]};${color[$k]}$rc" 
		fg_no_bold[${k#fg-}]="$lc${color[normal]};${color[$k]}$rc" 
	done
	typeset -AHg bg bg_bold bg_no_bold
	for k in ${(k)color[(I)bg-*]}
	do
		bg[${k#bg-}]="$lc${color[$k]}$rc" 
		bg_bold[${k#bg-}]="$lc${color[bold]};${color[$k]}$rc" 
		bg_no_bold[${k#bg-}]="$lc${color[normal]};${color[$k]}$rc" 
	done
}
compadd () {
	local -A apre hpre dscrs _oad _mesg
	local -a isfile _opts __ expl
	zparseopts -a _opts P:=apre p:=hpre d:=dscrs X+:=expl O:=_oad A:=_oad D:=_oad f=isfile i: S: s: I: x:=_mesg r: R: W: F: M+: E: q e Q n U C J:=__ V:=__ a=__ l=__ k=__ o::=__ 1=__ 2=__
	_ftb_curcontext=${curcontext#:} 
	if (( $#_oad != 0 || ! IN_FZF_TAB )) || {
			-ftb-zstyle -m disabled-on "any"
		} || (
			{
				-ftb-zstyle -m disabled-on "files"
			} && [[ -n $isfile ]]
		)
	then
		builtin compadd "$@"
		return
	fi
	local -a __hits __dscr
	if (( $#dscrs == 1 ))
	then
		__dscr=("${(@P)${(v)dscrs}}") 
	fi
	builtin compadd -A __hits -D __dscr "$@"
	local ret=$? 
	if (( $#__hits == 0 ))
	then
		if is-at-least 5.9 && (( $#_mesg != 0 ))
		then
			builtin compadd -x $_mesg
		fi
		return $ret
	fi
	expl=$expl[2] 
	[[ -n $expl ]] && _ftb_groups+=$expl 
	local -a keys=(apre hpre PREFIX SUFFIX IPREFIX ISUFFIX) 
	local key expanded __tmp_value=$'<\0>' 
	for key in $keys
	do
		expanded=${(P)key} 
		if [[ -n $expanded ]]
		then
			__tmp_value+=$'\0'$key$'\0'$expanded 
		fi
	done
	if [[ -n $expl ]]
	then
		__tmp_value+=$'\0group\0'$_ftb_groups[(ie)$expl] 
	fi
	if [[ -n $isfile ]]
	then
		__tmp_value+=$'\0realdir\0'${${(Qe)~${:-$IPREFIX$hpre}}} 
	fi
	_opts+=("${(@kv)apre}" "${(@kv)hpre}" $isfile) 
	__tmp_value+=$'\0args\0'${(pj:\1:)_opts} 
	if (( $+builtins[fzf-tab-compcap-generate] ))
	then
		fzf-tab-compcap-generate __hits __dscr __tmp_value
	else
		local dscr word i
		for i in {1..$#__hits}
		do
			word=$__hits[i] dscr=$__dscr[i] 
			if [[ -n $dscr ]]
			then
				dscr=${dscr//$'\n'} 
			elif [[ -n $word ]]
			then
				dscr=$word 
			fi
			_ftb_compcap+=$dscr$'\2'$__tmp_value$'\0word\0'$word 
		done
	fi
	builtin compadd "$@"
}
compaudit () {
	# undefined
	builtin autoload -XUz /usr/share/zsh/5.9/functions
}
compdef () {
	local opt autol type func delete eval new i ret=0 cmd svc 
	local -a match mbegin mend
	emulate -L zsh
	setopt extendedglob
	if (( ! $# ))
	then
		print -u2 "$0: I need arguments"
		return 1
	fi
	while getopts "anpPkKde" opt
	do
		case "$opt" in
			(a) autol=yes  ;;
			(n) new=yes  ;;
			([pPkK]) if [[ -n "$type" ]]
				then
					print -u2 "$0: type already set to $type"
					return 1
				fi
				if [[ "$opt" = p ]]
				then
					type=pattern 
				elif [[ "$opt" = P ]]
				then
					type=postpattern 
				elif [[ "$opt" = K ]]
				then
					type=widgetkey 
				else
					type=key 
				fi ;;
			(d) delete=yes  ;;
			(e) eval=yes  ;;
		esac
	done
	shift OPTIND-1
	if (( ! $# ))
	then
		print -u2 "$0: I need arguments"
		return 1
	fi
	if [[ -z "$delete" ]]
	then
		if [[ -z "$eval" ]] && [[ "$1" = *\=* ]]
		then
			while (( $# ))
			do
				if [[ "$1" = *\=* ]]
				then
					cmd="${1%%\=*}" 
					svc="${1#*\=}" 
					func="$_comps[${_services[(r)$svc]:-$svc}]" 
					[[ -n ${_services[$svc]} ]] && svc=${_services[$svc]} 
					[[ -z "$func" ]] && func="${${_patcomps[(K)$svc][1]}:-${_postpatcomps[(K)$svc][1]}}" 
					if [[ -n "$func" ]]
					then
						_comps[$cmd]="$func" 
						_services[$cmd]="$svc" 
					else
						print -u2 "$0: unknown command or service: $svc"
						ret=1 
					fi
				else
					print -u2 "$0: invalid argument: $1"
					ret=1 
				fi
				shift
			done
			return ret
		fi
		func="$1" 
		[[ -n "$autol" ]] && autoload -rUz "$func"
		shift
		case "$type" in
			(widgetkey) while [[ -n $1 ]]
				do
					if [[ $# -lt 3 ]]
					then
						print -u2 "$0: compdef -K requires <widget> <comp-widget> <key>"
						return 1
					fi
					[[ $1 = _* ]] || 1="_$1" 
					[[ $2 = .* ]] || 2=".$2" 
					[[ $2 = .menu-select ]] && zmodload -i zsh/complist
					zle -C "$1" "$2" "$func"
					if [[ -n $new ]]
					then
						bindkey "$3" | IFS=$' \t' read -A opt
						[[ $opt[-1] = undefined-key ]] && bindkey "$3" "$1"
					else
						bindkey "$3" "$1"
					fi
					shift 3
				done ;;
			(key) if [[ $# -lt 2 ]]
				then
					print -u2 "$0: missing keys"
					return 1
				fi
				if [[ $1 = .* ]]
				then
					[[ $1 = .menu-select ]] && zmodload -i zsh/complist
					zle -C "$func" "$1" "$func"
				else
					[[ $1 = menu-select ]] && zmodload -i zsh/complist
					zle -C "$func" ".$1" "$func"
				fi
				shift
				for i
				do
					if [[ -n $new ]]
					then
						bindkey "$i" | IFS=$' \t' read -A opt
						[[ $opt[-1] = undefined-key ]] || continue
					fi
					bindkey "$i" "$func"
				done ;;
			(*) while (( $# ))
				do
					if [[ "$1" = -N ]]
					then
						type=normal 
					elif [[ "$1" = -p ]]
					then
						type=pattern 
					elif [[ "$1" = -P ]]
					then
						type=postpattern 
					else
						case "$type" in
							(pattern) if [[ $1 = (#b)(*)=(*) ]]
								then
									_patcomps[$match[1]]="=$match[2]=$func" 
								else
									_patcomps[$1]="$func" 
								fi ;;
							(postpattern) if [[ $1 = (#b)(*)=(*) ]]
								then
									_postpatcomps[$match[1]]="=$match[2]=$func" 
								else
									_postpatcomps[$1]="$func" 
								fi ;;
							(*) if [[ "$1" = *\=* ]]
								then
									cmd="${1%%\=*}" 
									svc=yes 
								else
									cmd="$1" 
									svc= 
								fi
								if [[ -z "$new" || -z "${_comps[$1]}" ]]
								then
									_comps[$cmd]="$func" 
									[[ -n "$svc" ]] && _services[$cmd]="${1#*\=}" 
								fi ;;
						esac
					fi
					shift
				done ;;
		esac
	else
		case "$type" in
			(pattern) unset "_patcomps[$^@]" ;;
			(postpattern) unset "_postpatcomps[$^@]" ;;
			(key) print -u2 "$0: cannot restore key bindings"
				return 1 ;;
			(*) unset "_comps[$^@]" ;;
		esac
	fi
}
compdump () {
	# undefined
	builtin autoload -XUz /usr/share/zsh/5.9/functions
}
compinit () {
	# undefined
	builtin autoload -XUz /usr/share/zsh/5.9/functions
}
compinstall () {
	# undefined
	builtin autoload -XUz /usr/share/zsh/5.9/functions
}
disable-fzf-tab () {
	emulate -L zsh -o extended_glob
	(( $+_ftb_orig_widget )) || return 0
	bindkey '^I' $_ftb_orig_widget
	case $_ftb_orig_list_grouped in
		(0) zstyle ':completion:*' list-grouped false ;;
		(1) zstyle ':completion:*' list-grouped true ;;
		(2) zstyle -d ':completion:*' list-grouped ;;
	esac
	unset _ftb_orig_widget _ftb_orig_list_groupded
	unfunction compadd 2> /dev/null
	functions[_main_complete]=$functions[_ftb__main_complete] 
	functions[_approximate]=$functions[_ftb__approximate] 
}
enable-fzf-tab () {
	emulate -L zsh -o extended_glob
	(( ! $+_ftb_orig_widget )) || disable-fzf-tab
	typeset -g _ftb_orig_widget="${${$(builtin bindkey '^I')##* }:-expand-or-complete}" 
	if (( ! $+widgets[.fzf-tab-orig-$_ftb_orig_widget] ))
	then
		local compinit_widgets=(complete-word delete-char-or-list expand-or-complete expand-or-complete-prefix list-choices menu-complete menu-expand-or-complete reverse-menu-complete) 
		if [[ $widgets[$_ftb_orig_widget] == builtin && $compinit_widgets[(Ie)$_ftb_orig_widget] != 0 ]]
		then
			zle -C .fzf-tab-orig-$_ftb_orig_widget .$_ftb_orig_widget _main_complete
		else
			zle -A $_ftb_orig_widget .fzf-tab-orig-$_ftb_orig_widget
		fi
	fi
	zstyle -t ':completion:*' list-grouped false
	typeset -g _ftb_orig_list_grouped=$? 
	zstyle ':completion:*' list-grouped false
	bindkey -M emacs '^I' fzf-tab-complete
	bindkey -M viins '^I' fzf-tab-complete
	bindkey -M emacs '^X.' fzf-tab-debug
	bindkey -M viins '^X.' fzf-tab-debug
	autoload +X -Uz _main_complete _approximate
	functions[compadd]=$functions[-ftb-compadd] 
	functions[_ftb__main_complete]=$functions[_main_complete] 
	_main_complete () {
		-ftb-complete "$@"
	}
	functions[_ftb__approximate]=$functions[_approximate] 
	_approximate () {
		(( ! IN_FZF_TAB )) || unfunction compadd
		_ftb__approximate
		(( ! IN_FZF_TAB )) || functions[compadd]=$functions[-ftb-compadd] 
	}
}
extract () {
	if [[ -f "$1" ]]
	then
		case "$1" in
			(*.tar.bz2) tar xjf "$1" ;;
			(*.tar.gz) tar xzf "$1" ;;
			(*.bz2) bunzip2 "$1" ;;
			(*.rar) unrar x "$1" ;;
			(*.gz) gunzip "$1" ;;
			(*.tar) tar xf "$1" ;;
			(*.tbz2) tar xjf "$1" ;;
			(*.tgz) tar xzf "$1" ;;
			(*.zip) unzip "$1" ;;
			(*.Z) uncompress "$1" ;;
			(*.7z) 7z x "$1" ;;
			(*) echo "'$1' cannot be extracted via extract()" ;;
		esac
	else
		echo "'$1' is not a valid file"
	fi
}
fast-theme () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/zdharma-continuum---fast-syntax-highlighting" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
ftb-switch-group () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
ftb-tmux-popup () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions" "/Users/danielr/.local/share/zinit/plugins/zsh-users---zsh-completions/src" "/Users/danielr/.local/share/zinit/plugins/Aloxaf---fzf-tab/lib") 
	builtin autoload -X -U -z
}
fzcd () {
	local dir
	dir=$(fd --type directory --hidden --exclude .git | fzf --preview 'eza --tree --color=always {} | head -200') 
	[[ -n "$dir" ]] && cd "$dir"
}
fzf-tab-complete () {
	local -i _ftb_continue=1 _ftb_continue_last=0 _ftb_accept=0 ret=0 
	echoti civis > /dev/tty 2> /dev/null
	while (( _ftb_continue ))
	do
		local _ftb_choices=() _ftb_compcap=() _ftb_finish=0 
		_ftb_continue=0 
		local IN_FZF_TAB=1 
		{
			zle .fzf-tab-orig-$_ftb_orig_widget || ret=$? 
			if (( ! ret && ! _ftb_finish ))
			then
				zle _fzf-tab-apply || ret=$? 
			fi
		} always {
			IN_FZF_TAB=0 
		}
		if (( _ftb_continue ))
		then
			zle .split-undo
			zle .reset-prompt
			zle -R
			zle fzf-tab-dummy
		fi
	done
	echoti cnorm > /dev/tty 2> /dev/null
	zle .redisplay
	(( _ftb_accept )) && zle .accept-line
	return $ret
}
fzf-tab-debug () {
	(( $+_ftb_debug_cnt )) || typeset -gi _ftb_debug_cnt
	local tmp=${TMPPREFIX:-/tmp/zsh}-$$-fzf-tab-$(( ++_ftb_debug_cnt )).log 
	local -i debug_fd=-1 IN_FZF_TAB=1 
	{
		exec {debug_fd}>&2 2>| $tmp
		local -a debug_indent
		debug_indent=('%'{3..20}'(e. .)') 
		local PROMPT4 PS4="${(j::)debug_indent}+%N:%i> " 
		functions -t -- -ftb-complete _fzf-tab-apply fzf-tab-complete
		{
			echo $ZSH_NAME $ZSH_VERSION
			echo fzf-tab: $(-ftb-version)
			typeset -p FZF_DEFAULT_OPTS
			echo $commands[fzf] $(fzf --version)
		} >&2
		zle fzf-tab-complete
		if (( debug_fd != -1 ))
		then
			zle -M "fzf-tab-debug: Trace output left in $tmp"
		fi
	} always {
		functions +t -- -ftb-complete _fzf-tab-apply fzf-tab-complete
		(( debug_fd != -1 )) && exec 2>&$debug_fd {debug_fd}>&-
	}
}
fzf-tab-dummy () {
	
}
fzf-tab-lscolors::from-mode () {
	emulate -L zsh
	setopt cbases octalzeroes extendedglob
	[[ -z $2 ]] && return 1
	local -i reg=0 
	local -a codes
	local -i st_mode=$(($2)) 
	case $(( st_mode & 0170000 )) in
		($(( 0140000 ))) codes=($modecolors[so])  ;;
		($(( 0120000 ))) if ! (($+3))
			then
				REPLY=$modecolors[or] 
			elif [[ $modecolors[ln] = target ]]
			then
				"$0" "$1" "${@:3}"
			else
				REPLY=$modecolors[ln] 
			fi
			return ;;
		($(( 0100000 ))) codes=() 
			reg=1  ;;
		($(( 0060000 ))) codes=($modecolors[bd])  ;;
		($(( 0040000 ))) codes=($modecolors[di])  ;;
		($(( 0020000 ))) codes=($modecolors[cd])  ;;
		($(( 0010000 ))) codes=($modecolors[pi])  ;;
	esac
	(( st_mode & 04000 )) && codes+=($modecolors[su]) 
	(( st_mode & 02000 )) && codes+=($modecolors[sg]) 
	(( ! reg )) && case $(( st_mode & 01002 )) in
		($(( 01000 ))) codes+=($modecolors[st])  ;;
		($(( 00002 ))) codes+=($modecolors[ow])  ;;
		($(( 01002 ))) codes+=($modecolors[tw])  ;;
	esac
	if (( ! $#codes ))
	then
		(( st_mode &  0111 )) && codes+=($modecolors[ex]) 
	fi
	[[ -n ${REPLY::=${(j:;:)codes}} ]]
}
fzf-tab-lscolors::from-name () {
	emulate -L zsh
	setopt extendedglob
	[[ -n ${REPLY::=$namecolors[(k)$1]} ]]
}
fzf-tab-lscolors::init () {
	emulate -L zsh
	local LS_COLORS=${1:-${LS_COLORS:-$LSCOLORS}} 
	typeset -gA namecolors=(${(@s:=:)${(@s.:.)LS_COLORS}:#[[:alpha:]][[:alpha:]]=*}) 
	typeset -gA modecolors=(${(@Ms:=:)${(@s.:.)LS_COLORS}:#[[:alpha:]][[:alpha:]]=*}) 
}
fzf-tab-lscolors::match-by () {
	emulate -L zsh
	setopt extendedglob cbases octalzeroes
	local arg REPLY name=$1 pfx=${0%::match-by} 
	shift
	if ! [[ -v namecolors && -v modecolors ]]
	then
		local -A namecolors modecolors
		${pfx}::init
	fi
	if [[ ${1:l} = (g|global) ]]
	then
		shift
	else
		local -a stat lstat
		declare -ga reply=() 
	fi
	zmodload -F zsh/stat b:zstat
	for arg
	do
		case ${arg[1]:l} in
			(n | name) ${pfx}::from-name $name
				reply+=("$REPLY")  ;;
			(l | lstat) (($#lstat)) || zstat -A lstat -L $name || return 1
				if ((lstat[3] & 0170000 ))
				then
					(($#stat)) || zstat -A stat $name 2> /dev/null
				fi
				${pfx}::from-mode "$name" "$lstat[3]" $stat[3]
				if [[ -n $REPLY || ${2[1]} = L ]]
				then
					reply+=("$REPLY") 
				else
					"$0" "$name" g n
				fi ;;
			(s | stat) (($#stat)) || zstat -A stat $name || return 1
				${pfx}::from-mode $name $stat[3]
				reply+=("$REPLY") 
				if [[ -n $REPLY || ${arg[1]} = S ]]
				then
					reply+=("$REPLY") 
				else
					"$0" "$name" g n
				fi ;;
			(f | follow) (($#lstat)) || zstat -A lstat -L $name || return 1
				reply+=("$lstat[14]")  ;;
			(a | all) "$0" "$name" g ${${${arg[1]%a}:+L}:-l}
				reply+=($lstat[14]) 
				if [[ -n $lstat[14] ]]
				then
					if [[ -e $name ]]
					then
						"$0" "$name" g ${${${arg[1]%a}:+S}:-s}
					else
						reply+=($reply[-2]) 
					fi
				fi ;;
			(*) return 2 ;;
		esac
	done
}
getColorCode () {
	eval "$__p9k_intro"
	if (( ARGC == 1 ))
	then
		case $1 in
			(foreground) local k
				for k in "${(k@)__p9k_colors}"
				do
					local v=${__p9k_colors[$k]} 
					print -rP -- "%F{$v}$v - $k%f"
				done
				return 0 ;;
			(background) local k
				for k in "${(k@)__p9k_colors}"
				do
					local v=${__p9k_colors[$k]} 
					print -rP -- "%K{$v}$v - $k%k"
				done
				return 0 ;;
		esac
	fi
	echo "Usage: getColorCode background|foreground" >&2
	return 1
}
get_icon_names () {
	eval "$__p9k_intro"
	_p9k_init_icons
	local key
	for key in ${(@kon)icons}
	do
		echo -n - "POWERLEVEL9K_$key: "
		print -nP "%K{red} %k"
		if [[ $1 == original ]]
		then
			echo -n - $icons[$key]
		else
			print_icon $key
		fi
		print -P "%K{red} %k"
	done
}
getent () {
	if [[ $1 = hosts ]]
	then
		sed 's/#.*//' /etc/$1 | grep -w $2
	elif [[ $2 = <-> ]]
	then
		grep ":$2:[^:]*$" /etc/$1
	else
		grep "^$2:" /etc/$1
	fi
}
git_help () {
	prompt=$(cat ~/.prompts/git-gud.md) 
	claude --system-prompt "$prompt" --append-system-prompt "$prompt" -p "Command to: $1"
}
history-substring-search-down () {
	_history-substring-search-begin
	_history-substring-search-down-history || _history-substring-search-down-buffer || _history-substring-search-down-search
	_history-substring-search-end
}
history-substring-search-up () {
	_history-substring-search-begin
	_history-substring-search-up-history || _history-substring-search-up-buffer || _history-substring-search-up-search
	_history-substring-search-end
}
instant_prompt__p9k_internal_nothing () {
	prompt__p9k_internal_nothing
}
instant_prompt_chezmoi_shell () {
	_p9k_prompt_segment prompt_chezmoi_shell blue $_p9k_color1 CHEZMOI_ICON 1 '$CHEZMOI_ICON' ''
}
instant_prompt_context () {
	if [[ $_POWERLEVEL9K_ALWAYS_SHOW_CONTEXT == 0 && -n $DEFAULT_USER && $P9K_SSH == 0 ]]
	then
		if [[ ${(%):-%n} == $DEFAULT_USER ]]
		then
			if (( ! _POWERLEVEL9K_ALWAYS_SHOW_USER ))
			then
				return
			fi
		fi
	fi
	prompt_context
}
instant_prompt_date () {
	_p9k_escape $_POWERLEVEL9K_DATE_FORMAT
	local stash='${${__p9k_instant_prompt_date::=${(%)${__p9k_instant_prompt_date_format::='$_p9k__ret'}}}+}' 
	_p9k_escape $_POWERLEVEL9K_DATE_FORMAT
	_p9k_prompt_segment prompt_date "$_p9k_color2" "$_p9k_color1" "DATE_ICON" 1 '' $stash$_p9k__ret
}
instant_prompt_dir () {
	prompt_dir
}
instant_prompt_dir_writable () {
	prompt_dir_writable
}
instant_prompt_direnv () {
	if [[ -n ${DIRENV_DIR:-} && $precmd_functions[-1] == _p9k_precmd ]]
	then
		_p9k_prompt_segment prompt_direnv $_p9k_color1 yellow DIRENV_ICON 0 '' ''
	fi
}
instant_prompt_example () {
	prompt_example
}
instant_prompt_host () {
	prompt_host
}
instant_prompt_lf () {
	_p9k_prompt_segment prompt_lf 6 $_p9k_color1 LF_ICON 1 '${LF_LEVEL:#0}' '$LF_LEVEL'
}
instant_prompt_midnight_commander () {
	_p9k_prompt_segment prompt_midnight_commander $_p9k_color1 yellow MIDNIGHT_COMMANDER_ICON 0 '$MC_TMPDIR' ''
}
instant_prompt_nix_shell () {
	_p9k_prompt_segment prompt_nix_shell 4 $_p9k_color1 NIX_SHELL_ICON 1 "$_p9k_nix_shell_cond" '${(M)IN_NIX_SHELL:#(pure|impure)}'
}
instant_prompt_nnn () {
	_p9k_prompt_segment prompt_nnn 6 $_p9k_color1 NNN_ICON 1 '${NNNLVL:#0}' '$NNNLVL'
}
instant_prompt_os_icon () {
	prompt_os_icon
}
instant_prompt_per_directory_history () {
	case $HISTORY_START_WITH_GLOBAL in
		(true) _p9k_prompt_segment prompt_per_directory_history_GLOBAL 3 $_p9k_color1 HISTORY_ICON 0 '' global ;;
		(?*) _p9k_prompt_segment prompt_per_directory_history_LOCAL 5 $_p9k_color1 HISTORY_ICON 0 '' local ;;
	esac
}
instant_prompt_prompt_char () {
	_p9k_prompt_segment prompt_prompt_char_OK_VIINS "$_p9k_color1" 76 '' 0 '' '❯'
}
instant_prompt_ranger () {
	_p9k_prompt_segment prompt_ranger $_p9k_color1 yellow RANGER_ICON 1 '$RANGER_LEVEL' '$RANGER_LEVEL'
}
instant_prompt_root_indicator () {
	prompt_root_indicator
}
instant_prompt_ssh () {
	if (( ! P9K_SSH ))
	then
		return
	fi
	prompt_ssh
}
instant_prompt_status () {
	if (( _POWERLEVEL9K_STATUS_OK ))
	then
		_p9k_prompt_segment prompt_status_OK "$_p9k_color1" green OK_ICON 0 '' ''
	fi
}
instant_prompt_time () {
	_p9k_escape $_POWERLEVEL9K_TIME_FORMAT
	local stash='${${__p9k_instant_prompt_time::=${(%)${__p9k_instant_prompt_time_format::='$_p9k__ret'}}}+}' 
	_p9k_escape $_POWERLEVEL9K_TIME_FORMAT
	_p9k_prompt_segment prompt_time "$_p9k_color2" "$_p9k_color1" "TIME_ICON" 1 '' $stash$_p9k__ret
}
instant_prompt_toolbox () {
	_p9k_prompt_segment prompt_toolbox $_p9k_color1 yellow TOOLBOX_ICON 1 '$P9K_TOOLBOX_NAME' '$P9K_TOOLBOX_NAME'
}
instant_prompt_user () {
	if [[ $_POWERLEVEL9K_ALWAYS_SHOW_USER == 0 && "${(%):-%n}" == $DEFAULT_USER ]]
	then
		return
	fi
	prompt_user
}
instant_prompt_vi_mode () {
	if [[ -n $_POWERLEVEL9K_VI_INSERT_MODE_STRING ]]
	then
		_p9k_prompt_segment prompt_vi_mode_INSERT "$_p9k_color1" blue '' 0 '' "$_POWERLEVEL9K_VI_INSERT_MODE_STRING"
	fi
}
instant_prompt_vim_shell () {
	_p9k_prompt_segment prompt_vim_shell green $_p9k_color1 VIM_ICON 0 '$VIMRUNTIME' ''
}
instant_prompt_xplr () {
	_p9k_prompt_segment prompt_xplr 6 $_p9k_color1 XPLR_ICON 0 '$XPLR_PID' ''
}
instant_prompt_yazi () {
	_p9k_prompt_segment prompt_yazi $_p9k_color1 yellow YAZI_ICON 1 '$YAZI_LEVEL' '$YAZI_LEVEL'
}
is-at-least () {
	emulate -L zsh
	local IFS=".-" min_cnt=0 ver_cnt=0 part min_ver version order 
	min_ver=(${=1}) 
	version=(${=2:-$ZSH_VERSION} 0) 
	while (( $min_cnt <= ${#min_ver} ))
	do
		while [[ "$part" != <-> ]]
		do
			(( ++ver_cnt > ${#version} )) && return 0
			if [[ ${version[ver_cnt]} = *[0-9][^0-9]* ]]
			then
				order=(${version[ver_cnt]} ${min_ver[ver_cnt]}) 
				if [[ ${version[ver_cnt]} = <->* ]]
				then
					[[ $order != ${${(On)order}} ]] && return 1
				else
					[[ $order != ${${(O)order}} ]] && return 1
				fi
				[[ $order[1] != $order[2] ]] && return 0
			fi
			part=${version[ver_cnt]##*[^0-9]} 
		done
		while true
		do
			(( ++min_cnt > ${#min_ver} )) && return 0
			[[ ${min_ver[min_cnt]} = <-> ]] && break
		done
		(( part > min_ver[min_cnt] )) && return 0
		(( part < min_ver[min_cnt] )) && return 1
		part='' 
	done
}
my_git_formatter () {
	emulate -L zsh
	if [[ -n $P9K_CONTENT ]]
	then
		typeset -g my_git_format=$P9K_CONTENT 
		return
	fi
	if (( $1 ))
	then
		local meta='%f' 
		local clean='%76F' 
		local modified='%178F' 
		local untracked='%39F' 
		local conflicted='%196F' 
	else
		local meta='%244F' 
		local clean='%244F' 
		local modified='%244F' 
		local untracked='%244F' 
		local conflicted='%244F' 
	fi
	local res
	if [[ -n $VCS_STATUS_LOCAL_BRANCH ]]
	then
		local branch=${(V)VCS_STATUS_LOCAL_BRANCH} 
		(( $#branch > 32 )) && branch[13,-13]=".." 
		res+="${clean}${(g::)POWERLEVEL9K_VCS_BRANCH_ICON}${branch//\%/%%}" 
	fi
	if [[ -n $VCS_STATUS_TAG && -z $VCS_STATUS_LOCAL_BRANCH ]]
	then
		local tag=${(V)VCS_STATUS_TAG} 
		(( $#tag > 32 )) && tag[13,-13]=".." 
		res+="${meta}#${clean}${tag//\%/%%}" 
	fi
	[[ -z $VCS_STATUS_LOCAL_BRANCH && -z $VCS_STATUS_TAG ]] && res+="${meta}@${clean}${VCS_STATUS_COMMIT[1,8]}" 
	if [[ -n ${VCS_STATUS_REMOTE_BRANCH:#$VCS_STATUS_LOCAL_BRANCH} ]]
	then
		res+="${meta}:${clean}${(V)VCS_STATUS_REMOTE_BRANCH//\%/%%}" 
	fi
	if [[ $VCS_STATUS_COMMIT_SUMMARY == (|*[^[:alnum:]])(wip|WIP)(|[^[:alnum:]]*) ]]
	then
		res+=" ${modified}wip" 
	fi
	if (( VCS_STATUS_COMMITS_AHEAD || VCS_STATUS_COMMITS_BEHIND ))
	then
		(( VCS_STATUS_COMMITS_BEHIND )) && res+=" ${clean}<${VCS_STATUS_COMMITS_BEHIND}" 
		(( VCS_STATUS_COMMITS_AHEAD && !VCS_STATUS_COMMITS_BEHIND )) && res+=" " 
		(( VCS_STATUS_COMMITS_AHEAD  )) && res+="${clean}>${VCS_STATUS_COMMITS_AHEAD}" 
	elif [[ -n $VCS_STATUS_REMOTE_BRANCH ]]
	then
		
	fi
	(( VCS_STATUS_PUSH_COMMITS_BEHIND )) && res+=" ${clean}<-${VCS_STATUS_PUSH_COMMITS_BEHIND}" 
	(( VCS_STATUS_PUSH_COMMITS_AHEAD && !VCS_STATUS_PUSH_COMMITS_BEHIND )) && res+=" " 
	(( VCS_STATUS_PUSH_COMMITS_AHEAD  )) && res+="${clean}->${VCS_STATUS_PUSH_COMMITS_AHEAD}" 
	(( VCS_STATUS_STASHES        )) && res+=" ${clean}*${VCS_STATUS_STASHES}" 
	[[ -n $VCS_STATUS_ACTION ]] && res+=" ${conflicted}${VCS_STATUS_ACTION}" 
	(( VCS_STATUS_NUM_CONFLICTED )) && res+=" ${conflicted}~${VCS_STATUS_NUM_CONFLICTED}" 
	(( VCS_STATUS_NUM_STAGED     )) && res+=" ${modified}+${VCS_STATUS_NUM_STAGED}" 
	(( VCS_STATUS_NUM_UNSTAGED   )) && res+=" ${modified}!${VCS_STATUS_NUM_UNSTAGED}" 
	(( VCS_STATUS_NUM_UNTRACKED  )) && res+=" ${untracked}${(g::)POWERLEVEL9K_VCS_UNTRACKED_ICON}${VCS_STATUS_NUM_UNTRACKED}" 
	(( VCS_STATUS_HAS_UNSTAGED == -1 )) && res+=" ${modified}-" 
	typeset -g my_git_format=$res 
}
nvim_file_open () {
	local pattern="${1:-.}" 
	local selected
	selected=$(fd --type file --hidden --exclude .git "$pattern" |
        fzf --preview 'bat --color=always --style=numbers {}' \
            --preview-window=right:60%) 
	[[ -n "$selected" ]] && nvim "$selected"
}
nvim_grep_open () {
	local query="$1" 
	if [[ -z "$query" ]]
	then
		echo "Usage: nvim_grep_open <search_term>"
		return 1
	fi
	local selected
	selected=$(rg --vimgrep --smart-case "$query" |
        fzf --delimiter : --nth=4.. \
            --preview 'bat --style=numbers --color=always --line-range {2}: --highlight-line {2} {1}' \
            --preview-window=up:70% \
            --bind 'enter:become(echo {1}:{2})') 
	if [[ -n "$selected" ]]
	then
		local file=$(echo "$selected" | cut -d: -f1) 
		local linenum=$(echo "$selected" | cut -d: -f2) 
		nvim "$file" "+$linenum"
	fi
}
p10k () {
	[[ $# != 1 || $1 != finalize ]] || {
		p10k-instant-prompt-finalize
		return 0
	}
	eval "$__p9k_intro_no_reply"
	if (( !ARGC ))
	then
		print -rP -- $__p9k_p10k_usage >&2
		return 1
	fi
	case $1 in
		(segment) local REPLY
			local -a reply
			shift
			local -i OPTIND
			local OPTARG opt state bg=0 fg icon cond text ref=0 expand=0 
			while getopts ':s:b:f:i:c:t:reh' opt
			do
				case $opt in
					(s) state=$OPTARG  ;;
					(b) bg=$OPTARG  ;;
					(f) fg=$OPTARG  ;;
					(i) icon=$OPTARG  ;;
					(c) cond=${OPTARG:-'${:-}'}  ;;
					(t) text=$OPTARG  ;;
					(r) ref=1  ;;
					(e) expand=1  ;;
					(+r) ref=0  ;;
					(+e) expand=0  ;;
					(h) print -rP -- $__p9k_p10k_segment_usage
						return 0 ;;
					(?) print -rP -- $__p9k_p10k_segment_usage >&2
						return 1 ;;
				esac
			done
			if (( OPTIND <= ARGC ))
			then
				print -rP -- $__p9k_p10k_segment_usage >&2
				return 1
			fi
			if [[ -z $_p9k__prompt_side ]]
			then
				print -rP -- "%1F[ERROR]%f %Bp10k segment%b: can be called only during prompt rendering." >&2
				if (( !ARGC ))
				then
					print -rP -- ""
					print -rP -- "For help, type:" >&2
					print -rP -- ""
					print -rP -- "  %2Fp10k%f %Bhelp%b %Bsegment%b" >&2
				fi
				return 1
			fi
			(( ref )) || icon=$'\1'$icon 
			typeset -i _p9k__has_upglob
			"_p9k_${_p9k__prompt_side}_prompt_segment" "prompt_${_p9k__segment_name}${state:+_${${(U)state}//İ/I}}" "$bg" "${fg:-$_p9k_color1}" "$icon" "$expand" "$cond" "$text"
			return 0 ;;
		(display) if (( ARGC == 1 ))
			then
				print -rP -- $__p9k_p10k_display_usage >&2
				return 1
			fi
			shift
			local -i k dump
			local opt prev new pair list name var
			while getopts ':har' opt
			do
				case $opt in
					(r) if (( __p9k_reset_state > 0 ))
						then
							__p9k_reset_state=2 
						else
							__p9k_reset_state=-1 
						fi ;;
					(a) dump=1  ;;
					(h) print -rP -- $__p9k_p10k_display_usage
						return 0 ;;
					(?) print -rP -- $__p9k_p10k_display_usage >&2
						return 1 ;;
				esac
			done
			if (( dump ))
			then
				reply=() 
				shift $((OPTIND-1))
				(( ARGC )) || set -- '*'
				for opt
				do
					for k in ${(u@)_p9k_display_k[(I)$opt]:/(#m)*/$_p9k_display_k[$MATCH]}
					do
						reply+=($_p9k__display_v[k,k+1]) 
					done
				done
				if (( __p9k_reset_state == -1 ))
				then
					_p9k_reset_prompt
				fi
				return 0
			fi
			local REPLY
			local -a reply
			for opt in "${@:$OPTIND}"
			do
				pair=(${(s:=:)opt}) 
				list=(${(s:,:)${pair[2]}}) 
				if [[ ${(b)pair[1]} == $pair[1] ]]
				then
					local ks=($_p9k_display_k[$pair[1]]) 
				else
					local ks=(${(u@)_p9k_display_k[(I)$pair[1]]:/(#m)*/$_p9k_display_k[$MATCH]}) 
				fi
				for k in $ks
				do
					if (( $#list == 1 ))
					then
						[[ $_p9k__display_v[k+1] == $list[1] ]] && continue
						new=$list[1] 
					else
						new=${list[list[(I)$_p9k__display_v[k+1]]+1]:-$list[1]} 
						[[ $_p9k__display_v[k+1] == $new ]] && continue
					fi
					_p9k__display_v[k+1]=$new 
					name=$_p9k__display_v[k] 
					if [[ $name == (empty_line|ruler) ]]
					then
						var=_p9k__${name}_i 
						[[ $new == show ]] && unset $var || typeset -gi $var=3
					elif [[ $name == (#b)(<->)(*) ]]
					then
						var=_p9k__${match[1]}${${${${match[2]//\/}/#left/l}/#right/r}/#gap/g} 
						[[ $new == hide ]] && typeset -g $var= || unset $var
					fi
					if (( __p9k_reset_state > 0 ))
					then
						__p9k_reset_state=2 
					else
						__p9k_reset_state=-1 
					fi
				done
			done
			if (( __p9k_reset_state == -1 ))
			then
				_p9k_reset_prompt
			fi ;;
		(configure) if (( ARGC > 1 ))
			then
				print -rP -- $__p9k_p10k_configure_usage >&2
				return 1
			fi
			local REPLY
			local -a reply
			p9k_configure "$@" || return ;;
		(reload) if (( ARGC > 1 ))
			then
				print -rP -- $__p9k_p10k_reload_usage >&2
				return 1
			fi
			(( $+_p9k__force_must_init )) || return 0
			_p9k__force_must_init=1  ;;
		(help) local var=__p9k_p10k_$2_usage 
			if (( $+parameters[$var] ))
			then
				print -rP -- ${(P)var}
				return 0
			elif (( ARGC == 1 ))
			then
				print -rP -- $__p9k_p10k_usage
				return 0
			else
				print -rP -- $__p9k_p10k_usage >&2
				return 1
			fi ;;
		(finalize) print -rP -- $__p9k_p10k_finalize_usage >&2
			return 1 ;;
		(clear-instant-prompt) if (( $+__p9k_instant_prompt_active ))
			then
				_p9k_clear_instant_prompt
				unset __p9k_instant_prompt_active
			fi
			return 0 ;;
		(*) print -rP -- $__p9k_p10k_usage >&2
			return 1 ;;
	esac
}
p10k-instant-prompt-finalize () {
	unsetopt local_options
	(( ${+__p9k_instant_prompt_active} )) && unsetopt prompt_cr prompt_sp || setopt prompt_cr prompt_sp
}
p9k_configure () {
	eval "$__p9k_intro"
	_p9k_can_configure || return
	(
		set -- -f
		builtin source $__p9k_root_dir/internal/wizard.zsh
	)
	local ret=$? 
	case $ret in
		(0) builtin source $__p9k_cfg_path
			_p9k__force_must_init=1  ;;
		(69) return 0 ;;
		(*) return $ret ;;
	esac
}
p9k_prompt_segment () {
	p10k segment "$@"
}
pmodload () {
	local -A ices
	(( ${+ICE} )) && ices=("${(kv)ICE[@]}" teleid '') 
	local -A ICE ZINIT_ICE
	ICE=("${(kv)ices[@]}") ZINIT_ICE=("${(kv)ices[@]}") 
	while (( $# ))
	do
		ICE[teleid]="PZT::modules/$1${ICE[svn]-/init.zsh}" 
		ZINIT_ICE[teleid]="PZT::modules/$1${ICE[svn]-/init.zsh}" 
		if zstyle -t ":prezto:module:$1" loaded 'yes' 'no'
		then
			shift
			continue
		else
			[[ -z ${ZINIT_SNIPPETS[PZT::modules/$1${ICE[svn]-/init.zsh}]} && -z ${ZINIT_SNIPPETS[https://github.com/sorin-ionescu/prezto/trunk/modules/$1${ICE[svn]-/init.zsh}]} ]] && .zinit-load-snippet PZT::modules/"$1${ICE[svn]-/init.zsh}"
			shift
		fi
	done
}
powerlevel10k_plugin_unload () {
	prompt_powerlevel9k_teardown
}
print_icon () {
	eval "$__p9k_intro"
	_p9k_init_icons
	local var=POWERLEVEL9K_$1 
	if (( $+parameters[$var] ))
	then
		echo -n - ${(P)var}
	else
		echo -n - $icons[$1]
	fi
}
prompt__p9k_internal_nothing () {
	_p9k__prompt+='${_p9k__sss::=}' 
}
prompt_anaconda () {
	local msg
	if _p9k_python_version
	then
		P9K_ANACONDA_PYTHON_VERSION=$_p9k__ret 
		if (( _POWERLEVEL9K_ANACONDA_SHOW_PYTHON_VERSION ))
		then
			msg="${P9K_ANACONDA_PYTHON_VERSION//\%/%%} " 
		fi
	else
		unset P9K_ANACONDA_PYTHON_VERSION
	fi
	local p=${CONDA_PREFIX:-$CONDA_ENV_PATH} 
	msg+="$_POWERLEVEL9K_ANACONDA_LEFT_DELIMITER${${p:t}//\%/%%}$_POWERLEVEL9K_ANACONDA_RIGHT_DELIMITER" 
	_p9k_prompt_segment "$0" "blue" "$_p9k_color1" 'PYTHON_ICON' 0 '' "$msg"
}
prompt_asdf () {
	_p9k_asdf_check_meta || _p9k_asdf_init_meta || return
	local -A versions
	local -a stat
	local -i has_global
	local dirs=($_p9k__parent_dirs) 
	local mtimes=($_p9k__parent_mtimes) 
	if [[ $dirs[-1] != ~ ]]
	then
		zstat -A stat +mtime ~ 2> /dev/null || return
		dirs+=(~) 
		mtimes+=($stat[1]) 
	fi
	local elem
	for elem in ${(@)${:-{1..$#dirs}}/(#m)*/${${:-$MATCH:$_p9k__asdf_dir2files[$dirs[MATCH]]}#$MATCH:$mtimes[MATCH]:}}
	do
		if [[ $elem == *:* ]]
		then
			local dir=$dirs[${elem%%:*}] 
			zstat -A stat +mtime $dir 2> /dev/null || return
			local files=($dir/.tool-versions(N) $dir/${(k)^_p9k_asdf_file_info}(N)) 
			_p9k__asdf_dir2files[$dir]=$stat[1]:${(pj:\0:)files} 
		else
			local files=(${(0)elem}) 
		fi
		if [[ ${files[1]:h} == ~ ]]
		then
			has_global=1 
			local -A local_versions=(${(kv)versions}) 
			versions=() 
		fi
		local file
		for file in $files
		do
			[[ $file == */.tool-versions ]]
			_p9k_asdf_parse_version_file $file $? || return
		done
	done
	if (( ! has_global ))
	then
		has_global=1 
		local -A local_versions=(${(kv)versions}) 
		versions=() 
	fi
	if [[ -r $ASDF_DEFAULT_TOOL_VERSIONS_FILENAME ]]
	then
		_p9k_asdf_parse_version_file $ASDF_DEFAULT_TOOL_VERSIONS_FILENAME 0 || return
	fi
	local plugin
	for plugin in ${(k)_p9k_asdf_plugins}
	do
		local upper=${${(U)plugin//-/_}//İ/I} 
		if (( $+parameters[_POWERLEVEL9K_ASDF_${upper}_SOURCES] ))
		then
			local sources=(${(P)${:-_POWERLEVEL9K_ASDF_${upper}_SOURCES}}) 
		else
			local sources=($_POWERLEVEL9K_ASDF_SOURCES) 
		fi
		local version="${(P)${:-ASDF_${upper}_VERSION}}" 
		if [[ -n $version ]]
		then
			(( $sources[(I)shell] )) || continue
		else
			version=$local_versions[$plugin] 
			if [[ -n $version ]]
			then
				(( $sources[(I)local] )) || continue
			else
				version=$versions[$plugin] 
				[[ -n $version ]] || continue
				(( $sources[(I)global] )) || continue
			fi
		fi
		if [[ $version == $versions[$plugin] ]]
		then
			if (( $+parameters[_POWERLEVEL9K_ASDF_${upper}_PROMPT_ALWAYS_SHOW] ))
			then
				(( _POWERLEVEL9K_ASDF_${upper}_PROMPT_ALWAYS_SHOW )) || continue
			else
				(( _POWERLEVEL9K_ASDF_PROMPT_ALWAYS_SHOW )) || continue
			fi
		fi
		if [[ $version == system ]]
		then
			if (( $+parameters[_POWERLEVEL9K_ASDF_${upper}_SHOW_SYSTEM] ))
			then
				(( _POWERLEVEL9K_ASDF_${upper}_SHOW_SYSTEM )) || continue
			else
				(( _POWERLEVEL9K_ASDF_SHOW_SYSTEM )) || continue
			fi
		fi
		_p9k_get_icon $0_$upper ${upper}_ICON $plugin
		_p9k_prompt_segment $0_$upper green $_p9k_color1 $'\1'$_p9k__ret 0 '' ${version//\%/%%}
	done
}
prompt_aws () {
	typeset -g P9K_AWS_PROFILE="${AWS_SSO_PROFILE:-${AWS_VAULT:-${AWSUME_PROFILE:-${AWS_PROFILE:-$AWS_DEFAULT_PROFILE}}}}" 
	local pat class state
	for pat class in "${_POWERLEVEL9K_AWS_CLASSES[@]}"
	do
		if [[ $P9K_AWS_PROFILE == ${~pat} ]]
		then
			[[ -n $class ]] && state=_${${(U)class}//İ/I} 
			break
		fi
	done
	if [[ -n ${AWS_REGION:-$AWS_DEFAULT_REGION} ]]
	then
		typeset -g P9K_AWS_REGION=${AWS_REGION:-$AWS_DEFAULT_REGION} 
	else
		local cfg=${AWS_CONFIG_FILE:-~/.aws/config} 
		if ! _p9k_cache_stat_get $0 $cfg
		then
			local -a reply
			_p9k_parse_aws_config $cfg
			_p9k_cache_stat_set $reply
		fi
		local prefix=$#P9K_AWS_PROFILE:$P9K_AWS_PROFILE: 
		local kv=$_p9k__cache_val[(r)${(b)prefix}*] 
		typeset -g P9K_AWS_REGION=${kv#$prefix} 
	fi
	_p9k_prompt_segment "$0$state" red white 'AWS_ICON' 0 '' "${P9K_AWS_PROFILE//\%/%%}"
}
prompt_aws_eb_env () {
	_p9k_upglob .elasticbeanstalk -/ && return
	local dir=$_p9k__parent_dirs[$?] 
	if ! _p9k_cache_stat_get $0 $dir/.elasticbeanstalk/config.yml
	then
		local env
		env="$(command eb list 2>/dev/null)"  || env= 
		env="${${(@M)${(@f)env}:#\* *}#\* }" 
		_p9k_cache_stat_set "$env"
	fi
	[[ -n $_p9k__cache_val[1] ]] || return
	_p9k_prompt_segment "$0" black green 'AWS_EB_ICON' 0 '' "${_p9k__cache_val[1]//\%/%%}"
}
prompt_azure () {
	local name cfg=${AZURE_CONFIG_DIR:-$HOME/.azure}/azureProfile.json 
	if _p9k_cache_stat_get $0 $cfg
	then
		name=$_p9k__cache_val[1] 
	else
		if (( $+commands[jq] )) && name="$(jq -r '[.subscriptions[]|select(.isDefault==true)|.name][]|strings' $cfg 2>/dev/null)" 
		then
			name=${name%%$'\n'*} 
		elif ! name="$(az account show --query name --output tsv 2>/dev/null)" 
		then
			name= 
		fi
		_p9k_cache_stat_set "$name"
	fi
	[[ -n $name ]] || return
	local pat class state
	for pat class in "${_POWERLEVEL9K_AZURE_CLASSES[@]}"
	do
		if [[ $name == ${~pat} ]]
		then
			[[ -n $class ]] && state=_${${(U)class}//İ/I} 
			break
		fi
	done
	_p9k_prompt_segment "$0$state" "blue" "white" "AZURE_ICON" 0 '' "${name//\%/%%}"
}
prompt_background_jobs () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	local msg
	if (( _POWERLEVEL9K_BACKGROUND_JOBS_VERBOSE ))
	then
		if (( _POWERLEVEL9K_BACKGROUND_JOBS_VERBOSE_ALWAYS ))
		then
			msg='${(%):-%j}' 
		else
			msg='${${(%):-%j}:#1}' 
		fi
	fi
	_p9k_prompt_segment $0 "$_p9k_color1" cyan BACKGROUND_JOBS_ICON 1 '${${(%):-%j}:#0}' "$msg"
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_battery () {
	[[ $_p9k_os == (Linux|Android) ]] && _p9k_prompt_battery_set_args
	(( $#_p9k__battery_args )) && _p9k_prompt_segment "${_p9k__battery_args[@]}"
}
prompt_chezmoi_shell () {
	_p9k_prompt_segment $0 blue $_p9k_color1 CHEZMOI_ICON 0 '' ''
}
prompt_chruby () {
	local v=${(M)RUBY_ENGINE:#$~_POWERLEVEL9K_CHRUBY_SHOW_ENGINE_PATTERN} 
	[[ $_POWERLEVEL9K_CHRUBY_SHOW_VERSION == 1 && -n $RUBY_VERSION ]] && v+=${v:+ }$RUBY_VERSION 
	_p9k_prompt_segment "$0" "red" "$_p9k_color1" 'RUBY_ICON' 0 '' "${v//\%/%%}"
}
prompt_command_execution_time () {
	(( $+P9K_COMMAND_DURATION_SECONDS )) || return
	(( P9K_COMMAND_DURATION_SECONDS >= _POWERLEVEL9K_COMMAND_EXECUTION_TIME_THRESHOLD )) || return
	if (( P9K_COMMAND_DURATION_SECONDS < 60 ))
	then
		if (( !_POWERLEVEL9K_COMMAND_EXECUTION_TIME_PRECISION ))
		then
			local -i sec=$((P9K_COMMAND_DURATION_SECONDS + 0.5)) 
		else
			local -F $_POWERLEVEL9K_COMMAND_EXECUTION_TIME_PRECISION sec=P9K_COMMAND_DURATION_SECONDS 
		fi
		local text=${sec}s 
	else
		local -i d=$((P9K_COMMAND_DURATION_SECONDS + 0.5)) 
		if [[ $_POWERLEVEL9K_COMMAND_EXECUTION_TIME_FORMAT == "H:M:S" ]]
		then
			local text=${(l.2..0.)$((d % 60))} 
			if (( d >= 60 ))
			then
				text=${(l.2..0.)$((d / 60 % 60))}:$text 
				if (( d >= 36000 ))
				then
					text=$((d / 3600)):$text 
				elif (( d >= 3600 ))
				then
					text=0$((d / 3600)):$text 
				fi
			fi
		else
			local text="$((d % 60))s" 
			if (( d >= 60 ))
			then
				text="$((d / 60 % 60))m $text" 
				if (( d >= 3600 ))
				then
					text="$((d / 3600 % 24))h $text" 
					if (( d >= 86400 ))
					then
						text="$((d / 86400))d $text" 
					fi
				fi
			fi
		fi
	fi
	_p9k_prompt_segment "$0" "red" "yellow1" 'EXECUTION_TIME_ICON' 0 '' $text
}
prompt_context () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	local content
	if [[ $_POWERLEVEL9K_ALWAYS_SHOW_CONTEXT == 0 && -n $DEFAULT_USER && $P9K_SSH == 0 ]]
	then
		local user="${(%):-%n}" 
		if [[ $user == $DEFAULT_USER ]]
		then
			content="${user//\%/%%}" 
		fi
	fi
	local state
	if (( P9K_SSH ))
	then
		if [[ -n "$SUDO_COMMAND" ]]
		then
			state="REMOTE_SUDO" 
		else
			state="REMOTE" 
		fi
	elif [[ -n "$SUDO_COMMAND" ]]
	then
		state="SUDO" 
	else
		state="DEFAULT" 
	fi
	local cond
	for state cond in $state '${${(%):-%#}:#\#}' ROOT '${${(%):-%#}:#\%}'
	do
		local text=$content 
		if [[ -z $text ]]
		then
			local var=_POWERLEVEL9K_CONTEXT_${state}_TEMPLATE 
			if (( $+parameters[$var] ))
			then
				text=${(P)var} 
				text=${(g::)text} 
			else
				text=$_POWERLEVEL9K_CONTEXT_TEMPLATE 
			fi
		fi
		_p9k_prompt_segment "$0_$state" "$_p9k_color1" yellow '' 0 "$cond" "$text"
	done
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_cpu_arch () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	local state text
	if _p9k_cache_ephemeral_get $0
	then
		state=$_p9k__cache_val[1] 
		text=$_p9k__cache_val[2] 
	else
		if [[ -r /proc/sys/kernel/arch ]]
		then
			text=$(</proc/sys/kernel/arch) 
		else
			local cmd
			for cmd in machine arch
			do
				(( $+commands[$cmd] )) || continue
				if text=$(command -- $cmd)  2> /dev/null && [[ $text == [a-zA-Z][a-zA-Z0-9_]# ]]
				then
					break
				else
					text= 
				fi
			done
		fi
		state=_${${(U)text}//İ/I} 
		_p9k_cache_ephemeral_set "$state" "$text"
	fi
	if [[ -n $text ]]
	then
		_p9k_prompt_segment "$0$state" "yellow" "$_p9k_color1" 'ARCH_ICON' 0 '' "$text"
	fi
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_date () {
	if [[ $_p9k__refresh_reason == precmd ]]
	then
		if [[ $+__p9k_instant_prompt_active == 1 && $__p9k_instant_prompt_date_format == $_POWERLEVEL9K_DATE_FORMAT ]]
		then
			_p9k__date=${__p9k_instant_prompt_date//\%/%%} 
		else
			_p9k__date=${${(%)_POWERLEVEL9K_DATE_FORMAT}//\%/%%} 
		fi
	fi
	_p9k_prompt_segment "$0" "$_p9k_color2" "$_p9k_color1" "DATE_ICON" 0 '' "$_p9k__date"
}
prompt_detect_virt () {
	local virt="$(systemd-detect-virt 2>/dev/null)" 
	if [[ "$virt" == "none" ]]
	then
		local -a inode
		if zstat -A inode +inode / 2> /dev/null && [[ $inode[1] != 2 ]]
		then
			virt="chroot" 
		fi
	fi
	if [[ -n "${virt}" ]]
	then
		_p9k_prompt_segment "$0" "$_p9k_color1" "yellow" '' 0 '' "${virt//\%/%%}"
	fi
}
prompt_dir () {
	if (( _POWERLEVEL9K_DIR_PATH_ABSOLUTE ))
	then
		local p=${(V)_p9k__cwd} 
		local -a parts=("${(s:/:)p}") 
	elif [[ -o auto_name_dirs ]]
	then
		local p=${(V)${_p9k__cwd/#(#b)$HOME(|\/*)/'~'$match[1]}} 
		local -a parts=("${(s:/:)p}") 
	else
		local p=${(%):-%~} 
		if [[ $p == '~['* ]]
		then
			local func='' 
			local -a parts=() 
			for func in zsh_directory_name $zsh_directory_name_functions
			do
				local reply=() 
				if (( $+functions[$func] )) && $func d $_p9k__cwd && [[ $p == '~['${(V)reply[1]}']'* ]]
				then
					parts+='~['${(V)reply[1]}']' 
					break
				fi
			done
			if (( $#parts ))
			then
				parts+=(${(s:/:)${p#$parts[1]}}) 
			else
				p=${(V)_p9k__cwd} 
				parts=("${(s:/:)p}") 
			fi
		else
			local -a parts=("${(s:/:)p}") 
		fi
	fi
	local -i fake_first=0 expand=0 shortenlen=${_POWERLEVEL9K_SHORTEN_DIR_LENGTH:--1} 
	if (( $+_POWERLEVEL9K_SHORTEN_DELIMITER ))
	then
		local delim=$_POWERLEVEL9K_SHORTEN_DELIMITER 
	else
		if [[ $langinfo[CODESET] == (utf|UTF)(-|)8 ]]
		then
			local delim=$'\u2026' 
		else
			local delim='..' 
		fi
	fi
	case $_POWERLEVEL9K_SHORTEN_STRATEGY in
		(truncate_absolute | truncate_absolute_chars) if (( shortenlen > 0 && $#p > shortenlen ))
			then
				_p9k_shorten_delim_len $delim
				if (( $#p > shortenlen + $_p9k__ret ))
				then
					local -i n=shortenlen 
					local -i i=$#parts 
					while true
					do
						local dir=$parts[i] 
						local -i len=$(( $#dir + (i > 1) )) 
						if (( len <= n ))
						then
							(( n -= len ))
							(( --i ))
						else
							parts[i]=$'\1'$dir[-n,-1] 
							parts[1,i-1]=() 
							break
						fi
					done
				fi
			fi ;;
		(truncate_with_package_name | truncate_middle | truncate_from_right) () {
				[[ $_POWERLEVEL9K_SHORTEN_STRATEGY == truncate_with_package_name && $+commands[jq] == 1 && $#_POWERLEVEL9K_DIR_PACKAGE_FILES > 0 ]] || return
				local pats="(${(j:|:)_POWERLEVEL9K_DIR_PACKAGE_FILES})" 
				local -i i=$#parts 
				local dir=$_p9k__cwd 
				for ((; i > 0; --i )) do
					local markers=($dir/${~pats}(N)) 
					if (( $#markers ))
					then
						local pat= pkg_file= 
						for pat in $_POWERLEVEL9K_DIR_PACKAGE_FILES
						do
							for pkg_file in $markers
							do
								[[ $pkg_file == $dir/${~pat} ]] || continue
								if ! _p9k_cache_stat_get $0_pkg $pkg_file
								then
									local pkg_name='' 
									pkg_name="$(jq -j '.name | select(. != null)' <$pkg_file 2>/dev/null)"  || pkg_name='' 
									_p9k_cache_stat_set "$pkg_name"
								fi
								[[ -n $_p9k__cache_val[1] ]] || continue
								parts[1,i]=($_p9k__cache_val[1]) 
								fake_first=1 
								return 0
							done
						done
					fi
					dir=${dir:h} 
				done
			}
			if (( shortenlen > 0 ))
			then
				_p9k_shorten_delim_len $delim
				local -i d=_p9k__ret pref=shortenlen suf=0 i=2 
				[[ $_POWERLEVEL9K_SHORTEN_STRATEGY == truncate_middle ]] && suf=pref 
				for ((; i < $#parts; ++i )) do
					local dir=$parts[i] 
					if (( $#dir > pref + suf + d ))
					then
						dir[pref+1,-suf-1]=$'\1' 
						parts[i]=$dir 
					fi
				done
			fi ;;
		(truncate_to_last) shortenlen=${_POWERLEVEL9K_SHORTEN_DIR_LENGTH:-1} 
			(( shortenlen > 0 )) || shortenlen=1 
			local -i i='shortenlen+1' 
			if [[ $#parts -gt i || ( $p[1] != / && $#parts -gt shortenlen ) ]]
			then
				fake_first=1 
				parts[1,-i]=() 
			fi ;;
		(truncate_to_first_and_last) if (( shortenlen > 0 ))
			then
				local -i i=$(( shortenlen + 1 )) 
				[[ $p == /* ]] && (( ++i ))
				for ((; i <= $#parts - shortenlen; ++i )) do
					parts[i]=$'\1' 
				done
			fi ;;
		(truncate_to_unique) expand=1 
			delim=${_POWERLEVEL9K_SHORTEN_DELIMITER-'*'} 
			shortenlen=${_POWERLEVEL9K_SHORTEN_DIR_LENGTH:-1} 
			(( shortenlen >= 0 )) || shortenlen=1 
			local rp=${(g:oce:)p} 
			local rparts=("${(@s:/:)rp}") 
			local -i i=2 e=$(($#parts - shortenlen)) 
			if [[ -n $_POWERLEVEL9K_DIR_TRUNCATE_BEFORE_MARKER ]]
			then
				(( e += shortenlen ))
				local orig=("$parts[2]" "${(@)parts[$((shortenlen > $#parts ? -$#parts : -shortenlen)),-1]}") 
			elif [[ $p[1] == / ]]
			then
				(( ++i ))
			fi
			if (( i <= e ))
			then
				local mtimes=(${(Oa)_p9k__parent_mtimes:$(($#parts-e)):$((e-i+1))}) 
				local key="${(pj.:.)mtimes}" 
			else
				local key= 
			fi
			if ! _p9k_cache_ephemeral_get $0 $e $i $_p9k__cwd $p || [[ $key != $_p9k__cache_val[1] ]]
			then
				local rtail=${(j./.)rparts[i,-1]} 
				local parent=$_p9k__cwd[1,-2-$#rtail] 
				_p9k_prompt_length $delim
				local -i real_delim_len=_p9k__ret 
				[[ -n $parts[i-1] ]] && parts[i-1]="\${(Q)\${:-${(qqq)${(q)parts[i-1]}}}}"$'\2' 
				local -i d=${_POWERLEVEL9K_SHORTEN_DELIMITER_LENGTH:--1} 
				(( d >= 0 )) || d=real_delim_len 
				local -i m=1 
				for ((; i <= e; ++i, ++m )) do
					local sub=$parts[i] 
					local rsub=$rparts[i] 
					local dir=$parent/$rsub mtime=$mtimes[m] 
					local pair=$_p9k__dir_stat_cache[$dir] 
					if [[ $pair == ${mtime:-x}:* ]]
					then
						parts[i]=${pair#*:} 
					else
						[[ $sub != *["~!#\`\$^&*()\\\"'<>?{}[]"]* ]]
						local -i q=$? 
						if [[ -n $_POWERLEVEL9K_SHORTEN_FOLDER_MARKER && -n $dir/${~_POWERLEVEL9K_SHORTEN_FOLDER_MARKER}(#qN) ]]
						then
							(( q )) && parts[i]="\${(Q)\${:-${(qqq)${(q)sub}}}}" 
							parts[i]+=$'\2' 
						else
							local -i j=$rsub[(i)[^.]] 
							for ((; j + d < $#rsub; ++j )) do
								local -a matching=($parent/$rsub[1,j]*/(N)) 
								(( $#matching == 1 )) && break
							done
							local -i saved=$((${(m)#${(V)${rsub:$j}}} - d)) 
							if (( saved > 0 ))
							then
								if (( q ))
								then
									parts[i]='${${${_p9k__d:#-*}:+${(Q)${:-'${(qqq)${(q)sub}}'}}}:-${(Q)${:-' 
									parts[i]+=$'\3'${(qqq)${(q)${(V)${rsub[1,j]}}}}$'}}\1\3''${$((_p9k__d+='$saved'))+}}' 
								else
									parts[i]='${${${_p9k__d:#-*}:+'$sub$'}:-\3'${(V)${rsub[1,j]}}$'\1\3''${$((_p9k__d+='$saved'))+}}' 
								fi
							else
								(( q )) && parts[i]="\${(Q)\${:-${(qqq)${(q)sub}}}}" 
							fi
						fi
						[[ -n $mtime ]] && _p9k__dir_stat_cache[$dir]="$mtime:$parts[i]" 
					fi
					parent+=/$rsub 
				done
				if [[ -n $_POWERLEVEL9K_DIR_TRUNCATE_BEFORE_MARKER ]]
				then
					local _2=$'\2' 
					if [[ $_POWERLEVEL9K_DIR_TRUNCATE_BEFORE_MARKER == last* ]]
					then
						(( e = ${parts[(I)*$_2]} + ${_POWERLEVEL9K_DIR_TRUNCATE_BEFORE_MARKER#*:} ))
					else
						(( e = ${parts[(ib:2:)*$_2]} + ${_POWERLEVEL9K_DIR_TRUNCATE_BEFORE_MARKER#*:} ))
					fi
					if (( e > 1 && e <= $#parts ))
					then
						parts[1,e-1]=() 
						fake_first=1 
					elif [[ $p == /?* ]]
					then
						parts[2]="\${(Q)\${:-${(qqq)${(q)orig[1]}}}}"$'\2' 
					fi
					for ((i = $#parts < shortenlen ? $#parts : shortenlen; i > 0; --i)) do
						[[ $#parts[-i] == *$'\2' ]] && continue
						if [[ $orig[-i] == *["~!#\`\$^&*()\\\"'<>?{}[]"]* ]]
						then
							parts[-i]='${(Q)${:-'${(qqq)${(q)orig[-i]}}'}}'$'\2' 
						else
							parts[-i]=${orig[-i]}$'\2' 
						fi
					done
				else
					for ((; i <= $#parts; ++i)) do
						[[ $parts[i] == *["~!#\`\$^&*()\\\"'<>?{}[]"]* ]] && parts[i]='${(Q)${:-'${(qqq)${(q)parts[i]}}'}}' 
						parts[i]+=$'\2' 
					done
				fi
				_p9k_cache_ephemeral_set "$key" "${parts[@]}"
			fi
			parts=("${(@)_p9k__cache_val[2,-1]}")  ;;
		(truncate_with_folder_marker) if [[ -n $_POWERLEVEL9K_SHORTEN_FOLDER_MARKER ]]
			then
				local dir=$_p9k__cwd 
				local -a m=() 
				local -i i=$(($#parts - 1)) 
				for ((; i > 1; --i )) do
					dir=${dir:h} 
					[[ -n $dir/${~_POWERLEVEL9K_SHORTEN_FOLDER_MARKER}(#qN) ]] && m+=$i 
				done
				m+=1 
				for ((i=1; i < $#m; ++i )) do
					(( m[i] - m[i+1] > 2 )) && parts[m[i+1]+1,m[i]-1]=($'\1') 
				done
			fi ;;
		(*) if (( shortenlen > 0 ))
			then
				local -i len=$#parts 
				[[ -z $parts[1] ]] && (( --len ))
				if (( len > shortenlen ))
				then
					parts[1,-shortenlen-1]=($'\1') 
				fi
			fi ;;
	esac
	(( !_POWERLEVEL9K_DIR_SHOW_WRITABLE )) || [[ -w $_p9k__cwd ]]
	local -i w=$? 
	(( w && _POWERLEVEL9K_DIR_SHOW_WRITABLE > 2 )) && [[ ! -e $_p9k__cwd ]] && w=2 
	if ! _p9k_cache_ephemeral_get $0 $_p9k__cwd $p $w $fake_first "${parts[@]}"
	then
		local state=$0 
		local icon='' 
		local a='' b='' c='' 
		for a b c in "${_POWERLEVEL9K_DIR_CLASSES[@]}"
		do
			if [[ $_p9k__cwd == ${~a} ]]
			then
				[[ -n $b ]] && state+=_${${(U)b}//İ/I} 
				icon=$'\1'$c 
				break
			fi
		done
		if (( w ))
		then
			if (( _POWERLEVEL9K_DIR_SHOW_WRITABLE == 1 ))
			then
				state=${0}_NOT_WRITABLE 
			elif (( w == 2 ))
			then
				state+=_NON_EXISTENT 
			else
				state+=_NOT_WRITABLE 
			fi
			icon=LOCK_ICON 
		fi
		local state_u=${${(U)state}//İ/I} 
		local style=%b 
		_p9k_color $state BACKGROUND blue
		_p9k_background $_p9k__ret
		style+=$_p9k__ret 
		_p9k_color $state FOREGROUND "$_p9k_color1"
		_p9k_foreground $_p9k__ret
		style+=$_p9k__ret 
		if (( expand ))
		then
			_p9k_escape_style $style
			style=$_p9k__ret 
		fi
		parts=("${(@)parts//\%/%%}") 
		if [[ $_POWERLEVEL9K_HOME_FOLDER_ABBREVIATION != '~' && $fake_first == 0 && $p == ('~'|'~/'*) ]]
		then
			(( expand )) && _p9k_escape $_POWERLEVEL9K_HOME_FOLDER_ABBREVIATION || _p9k__ret=$_POWERLEVEL9K_HOME_FOLDER_ABBREVIATION 
			parts[1]=$_p9k__ret 
			[[ $_p9k__ret == *%* ]] && parts[1]+=$style 
		elif [[ $_POWERLEVEL9K_DIR_OMIT_FIRST_CHARACTER == 1 && $fake_first == 0 && $#parts > 1 && -z $parts[1] && -n $parts[2] ]]
		then
			parts[1]=() 
		fi
		local last_style= 
		_p9k_param $state PATH_HIGHLIGHT_BOLD ''
		[[ $_p9k__ret == true ]] && last_style+=%B 
		if (( $+parameters[_POWERLEVEL9K_DIR_PATH_HIGHLIGHT_FOREGROUND] ||
          $+parameters[_POWERLEVEL9K_${state_u}_PATH_HIGHLIGHT_FOREGROUND] ))
		then
			_p9k_color $state PATH_HIGHLIGHT_FOREGROUND ''
			_p9k_foreground $_p9k__ret
			last_style+=$_p9k__ret 
		fi
		if [[ -n $last_style ]]
		then
			(( expand )) && _p9k_escape_style $last_style || _p9k__ret=$last_style 
			parts[-1]=$_p9k__ret${parts[-1]//$'\1'/$'\1'$_p9k__ret}$style 
		fi
		local anchor_style= 
		_p9k_param $state ANCHOR_BOLD ''
		[[ $_p9k__ret == true ]] && anchor_style+=%B 
		if (( $+parameters[_POWERLEVEL9K_DIR_ANCHOR_FOREGROUND] ||
          $+parameters[_POWERLEVEL9K_${state_u}_ANCHOR_FOREGROUND] ))
		then
			_p9k_color $state ANCHOR_FOREGROUND ''
			_p9k_foreground $_p9k__ret
			anchor_style+=$_p9k__ret 
		fi
		if [[ -n $anchor_style ]]
		then
			(( expand )) && _p9k_escape_style $anchor_style || _p9k__ret=$anchor_style 
			if [[ -z $last_style ]]
			then
				parts=("${(@)parts/%(#b)(*)$'\2'/$_p9k__ret$match[1]$style}") 
			else
				(( $#parts > 1 )) && parts[1,-2]=("${(@)parts[1,-2]/%(#b)(*)$'\2'/$_p9k__ret$match[1]$style}") 
				parts[-1]=${parts[-1]/$'\2'} 
			fi
		else
			parts=("${(@)parts/$'\2'}") 
		fi
		if (( $+parameters[_POWERLEVEL9K_DIR_SHORTENED_FOREGROUND] ||
          $+parameters[_POWERLEVEL9K_${state_u}_SHORTENED_FOREGROUND] ))
		then
			_p9k_color $state SHORTENED_FOREGROUND ''
			_p9k_foreground $_p9k__ret
			(( expand )) && _p9k_escape_style $_p9k__ret
			local shortened_fg=$_p9k__ret 
			(( expand )) && _p9k_escape $delim || _p9k__ret=$delim 
			[[ $_p9k__ret == *%* ]] && _p9k__ret+=$style$shortened_fg 
			parts=("${(@)parts/(#b)$'\3'(*)$'\1'(*)$'\3'/$shortened_fg$match[1]$_p9k__ret$match[2]$style}") 
			parts=("${(@)parts/(#b)(*)$'\1'(*)/$shortened_fg$match[1]$_p9k__ret$match[2]$style}") 
		else
			(( expand )) && _p9k_escape $delim || _p9k__ret=$delim 
			[[ $_p9k__ret == *%* ]] && _p9k__ret+=$style 
			parts=("${(@)parts/$'\1'/$_p9k__ret}") 
			parts=("${(@)parts//$'\3'}") 
		fi
		if [[ $_p9k__cwd == / && $_POWERLEVEL9K_DIR_OMIT_FIRST_CHARACTER == 1 ]]
		then
			local sep='/' 
		else
			local sep='' 
			if (( $+parameters[_POWERLEVEL9K_DIR_PATH_SEPARATOR_FOREGROUND] ||
            $+parameters[_POWERLEVEL9K_${state_u}_PATH_SEPARATOR_FOREGROUND] ))
			then
				_p9k_color $state PATH_SEPARATOR_FOREGROUND ''
				_p9k_foreground $_p9k__ret
				(( expand )) && _p9k_escape_style $_p9k__ret
				sep=$_p9k__ret 
			fi
			_p9k_param $state PATH_SEPARATOR /
			_p9k__ret=${(g::)_p9k__ret} 
			(( expand )) && _p9k_escape $_p9k__ret
			sep+=$_p9k__ret 
			[[ $sep == *%* ]] && sep+=$style 
		fi
		local content="${(pj.$sep.)parts}" 
		if (( _POWERLEVEL9K_DIR_HYPERLINK && _p9k_term_has_href )) && [[ $_p9k__cwd == /* ]]
		then
			_p9k_url_escape $_p9k__cwd
			local header=$'%{\e]8;;file://'$_p9k__ret$'\a%}' 
			local footer=$'%{\e]8;;\a%}' 
			if (( expand ))
			then
				_p9k_escape $header
				header=$_p9k__ret 
				_p9k_escape $footer
				footer=$_p9k__ret 
			fi
			content=$header$content$footer 
		fi
		(( expand )) && _p9k_prompt_length "${(e):-"\${\${_p9k__d::=0}+}$content"}" || _p9k__ret= 
		_p9k_cache_ephemeral_set "$state" "$icon" "$expand" "$content" $_p9k__ret
	fi
	if (( _p9k__cache_val[3] ))
	then
		if (( $+_p9k__dir ))
		then
			_p9k__cache_val[4]='${${_p9k__d::=-1024}+}'$_p9k__cache_val[4] 
		else
			_p9k__dir=$_p9k__cache_val[4] 
			_p9k__dir_len=$_p9k__cache_val[5] 
			_p9k__cache_val[4]='%{d%}'$_p9k__cache_val[4]'%{d%}' 
		fi
	fi
	_p9k_prompt_segment "$_p9k__cache_val[1]" "blue" "$_p9k_color1" "$_p9k__cache_val[2]" "$_p9k__cache_val[3]" "" "$_p9k__cache_val[4]"
}
prompt_dir_writable () {
	if [[ ! -w "$_p9k__cwd_a" ]]
	then
		_p9k_prompt_segment "$0_FORBIDDEN" "red" "yellow1" 'LOCK_ICON' 0 '' ''
	fi
}
prompt_direnv () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment $0 $_p9k_color1 yellow DIRENV_ICON 0 '${DIRENV_DIR-}' ''
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_disk_usage () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment $0_CRITICAL red white DISK_ICON 1 '$_p9k__disk_usage_critical' '$_p9k__disk_usage_pct%%'
	_p9k_prompt_segment $0_WARNING yellow $_p9k_color1 DISK_ICON 1 '$_p9k__disk_usage_warning' '$_p9k__disk_usage_pct%%'
	if (( ! _POWERLEVEL9K_DISK_USAGE_ONLY_WARNING ))
	then
		_p9k_prompt_segment $0_NORMAL $_p9k_color1 yellow DISK_ICON 1 '$_p9k__disk_usage_normal' '$_p9k__disk_usage_pct%%'
	fi
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_docker_machine () {
	_p9k_prompt_segment "$0" "magenta" "$_p9k_color1" 'SERVER_ICON' 0 '' "${DOCKER_MACHINE_NAME//\%/%%}"
}
prompt_dotnet_version () {
	if (( _POWERLEVEL9K_DOTNET_VERSION_PROJECT_ONLY ))
	then
		_p9k_upglob 'project.json|global.json|packet.dependencies|*.csproj|*.fsproj|*.xproj|*.sln' -. && return
	fi
	local cfg
	_p9k_upglob global.json -. || cfg=$_p9k__parent_dirs[$?]/global.json 
	_p9k_cached_cmd 0 "$cfg" dotnet --version || return
	_p9k_prompt_segment "$0" "magenta" "white" 'DOTNET_ICON' 0 '' "$_p9k__ret"
}
prompt_dropbox () {
	local dropbox_status="$(dropbox-cli filestatus . | cut -d\  -f2-)" 
	if [[ "$dropbox_status" != 'unwatched' && "$dropbox_status" != "isn't running!" ]]
	then
		if [[ "$dropbox_status" =~ 'up to date' ]]
		then
			dropbox_status="" 
		fi
		_p9k_prompt_segment "$0" "white" "blue" "DROPBOX_ICON" 0 '' "${dropbox_status//\%/%%}"
	fi
}
prompt_example () {
	p10k segment -f 208 -i '*' -t 'hello, %n'
}
prompt_fvm () {
	_p9k_fvm_new || _p9k_fvm_old
}
prompt_gcloud () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment $0_PARTIAL blue white GCLOUD_ICON 1 '${${(M)${#P9K_GCLOUD_PROJECT_NAME}:#0}:+$P9K_GCLOUD_ACCOUNT$P9K_GCLOUD_PROJECT_ID}' '${P9K_GCLOUD_ACCOUNT//\%/%%}:${P9K_GCLOUD_PROJECT_ID//\%/%%}'
	_p9k_prompt_segment $0_COMPLETE blue white GCLOUD_ICON 1 '$P9K_GCLOUD_PROJECT_NAME' '${P9K_GCLOUD_ACCOUNT//\%/%%}:${P9K_GCLOUD_PROJECT_ID//\%/%%}'
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_go_version () {
	_p9k_cached_cmd 0 '' go version || return
	[[ $_p9k__ret == (#b)*go([[:digit:].]##)* ]] || return
	local v=$match[1] 
	if (( _POWERLEVEL9K_GO_VERSION_PROJECT_ONLY ))
	then
		local p=$GOPATH 
		if [[ -z $p ]]
		then
			if [[ -d $HOME/go ]]
			then
				p=$HOME/go 
			else
				p="$(go env GOPATH 2>/dev/null)"  && [[ -n $p ]] || return
			fi
		fi
		if [[ $_p9k__cwd/ != $p/* && $_p9k__cwd_a/ != $p/* ]]
		then
			_p9k_upglob go.mod -. && return
		fi
	fi
	_p9k_prompt_segment "$0" "green" "grey93" "GO_ICON" 0 '' "${v//\%/%%}"
}
prompt_goenv () {
	local v=${(j.:.)${(@)${(s.:.)GOENV_VERSION}#go-}} 
	if [[ -n $v ]]
	then
		(( ${_POWERLEVEL9K_GOENV_SOURCES[(I)shell]} )) || return
	else
		(( ${_POWERLEVEL9K_GOENV_SOURCES[(I)local|global]} )) || return
		_p9k__ret= 
		if [[ $GOENV_DIR != (|.) ]]
		then
			[[ $GOENV_DIR == /* ]] && local dir=$GOENV_DIR  || local dir="$_p9k__cwd_a/$GOENV_DIR" 
			dir=${dir:A} 
			if [[ $dir != $_p9k__cwd_a ]]
			then
				while true
				do
					if _p9k_read_pyenv_like_version_file $dir/.go-version go-
					then
						(( ${_POWERLEVEL9K_GOENV_SOURCES[(I)local]} )) || return
						break
					fi
					[[ $dir == (/|.) ]] && break
					dir=${dir:h} 
				done
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			_p9k_upglob .go-version -.
			local -i idx=$? 
			if (( idx )) && _p9k_read_pyenv_like_version_file $_p9k__parent_dirs[idx]/.go-version go-
			then
				(( ${_POWERLEVEL9K_GOENV_SOURCES[(I)local]} )) || return
			else
				_p9k__ret= 
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			(( _POWERLEVEL9K_GOENV_PROMPT_ALWAYS_SHOW )) || return
			(( ${_POWERLEVEL9K_GOENV_SOURCES[(I)global]} )) || return
			_p9k_goenv_global_version
		fi
		v=$_p9k__ret 
	fi
	if (( !_POWERLEVEL9K_GOENV_PROMPT_ALWAYS_SHOW ))
	then
		_p9k_goenv_global_version
		[[ $v == $_p9k__ret ]] && return
	fi
	if (( !_POWERLEVEL9K_GOENV_SHOW_SYSTEM ))
	then
		[[ $v == system ]] && return
	fi
	_p9k_prompt_segment "$0" "blue" "$_p9k_color1" 'GO_ICON' 0 '' "${v//\%/%%}"
}
prompt_google_app_cred () {
	unset P9K_GOOGLE_APP_CRED_{TYPE,PROJECT_ID,CLIENT_EMAIL}
	if ! _p9k_cache_stat_get $0 $GOOGLE_APPLICATION_CREDENTIALS
	then
		local -a lines
		local q='[.type//"", .project_id//"", .client_email//"", 0][]' 
		if lines=("${(@f)$(jq -r $q <$GOOGLE_APPLICATION_CREDENTIALS 2>/dev/null)}")  && (( $#lines == 4 ))
		then
			local text="${(j.:.)lines[1,-2]}" 
			local pat class state
			for pat class in "${_POWERLEVEL9K_GOOGLE_APP_CRED_CLASSES[@]}"
			do
				if [[ $text == ${~pat} ]]
				then
					[[ -n $class ]] && state=_${${(U)class}//İ/I} 
					break
				fi
			done
			_p9k_cache_stat_set 1 "${(@)lines[1,-2]}" "$text" "$state"
		else
			_p9k_cache_stat_set 0
		fi
	fi
	(( _p9k__cache_val[1] )) || return
	P9K_GOOGLE_APP_CRED_TYPE=$_p9k__cache_val[2] 
	P9K_GOOGLE_APP_CRED_PROJECT_ID=$_p9k__cache_val[3] 
	P9K_GOOGLE_APP_CRED_CLIENT_EMAIL=$_p9k__cache_val[4] 
	_p9k_prompt_segment "$0$_p9k__cache_val[6]" "blue" "white" "GCLOUD_ICON" 0 '' "$_p9k__cache_val[5]"
}
prompt_haskell_stack () {
	if [[ -n $STACK_YAML ]]
	then
		(( ${_POWERLEVEL9K_HASKELL_STACK_SOURCES[(I)shell]} )) || return
		_p9k_haskell_stack_version $STACK_YAML
	else
		(( ${_POWERLEVEL9K_HASKELL_STACK_SOURCES[(I)local|global]} )) || return
		if _p9k_upglob stack.yaml -.
		then
			(( _POWERLEVEL9K_HASKELL_STACK_PROMPT_ALWAYS_SHOW )) || return
			(( ${_POWERLEVEL9K_HASKELL_STACK_SOURCES[(I)global]} )) || return
			_p9k_haskell_stack_version ${STACK_ROOT:-~/.stack}/global-project/stack.yaml
		else
			local -i idx=$? 
			(( ${_POWERLEVEL9K_HASKELL_STACK_SOURCES[(I)local]} )) || return
			_p9k_haskell_stack_version $_p9k__parent_dirs[idx]/stack.yaml
		fi
	fi
	[[ -n $_p9k__ret ]] || return
	local v=$_p9k__ret 
	if (( !_POWERLEVEL9K_HASKELL_STACK_PROMPT_ALWAYS_SHOW ))
	then
		_p9k_haskell_stack_version ${STACK_ROOT:-~/.stack}/global-project/stack.yaml
		[[ $v == $_p9k__ret ]] && return
	fi
	_p9k_prompt_segment "$0" "yellow" "$_p9k_color1" 'HASKELL_ICON' 0 '' "${v//\%/%%}"
}
prompt_history () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment "$0" "grey50" "$_p9k_color1" '' 0 '' '%h'
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_host () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	if (( P9K_SSH ))
	then
		_p9k_prompt_segment "$0_REMOTE" "${_p9k_color1}" yellow SSH_ICON 0 '' "$_POWERLEVEL9K_HOST_TEMPLATE"
	else
		_p9k_prompt_segment "$0_LOCAL" "${_p9k_color1}" yellow HOST_ICON 0 '' "$_POWERLEVEL9K_HOST_TEMPLATE"
	fi
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_ip () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment "$0" "cyan" "$_p9k_color1" 'NETWORK_ICON' 1 '$P9K_IP_IP' '$P9K_IP_IP'
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_java_version () {
	if (( _POWERLEVEL9K_JAVA_VERSION_PROJECT_ONLY ))
	then
		_p9k_upglob 'pom.xml|build.gradle.kts|build.sbt|deps.edn|project.clj|build.boot|*.(java|class|jar|gradle|clj|cljc)' -. && return
	fi
	local java=$commands[java] 
	if ! _p9k_cache_stat_get $0 $java ${JAVA_HOME:+$JAVA_HOME/release}
	then
		local v
		v="$(java -fullversion 2>&1)"  || v= 
		v=${${v#*\"}%\"*} 
		(( _POWERLEVEL9K_JAVA_VERSION_FULL )) || v=${v%%-*} 
		_p9k_cache_stat_set "${v//\%/%%}"
	fi
	[[ -n $_p9k__cache_val[1] ]] || return
	_p9k_prompt_segment "$0" "red" "white" "JAVA_ICON" 0 '' $_p9k__cache_val[1]
}
prompt_jenv () {
	if [[ -n $JENV_VERSION ]]
	then
		(( ${_POWERLEVEL9K_JENV_SOURCES[(I)shell]} )) || return
		local v=$JENV_VERSION 
	else
		(( ${_POWERLEVEL9K_JENV_SOURCES[(I)local|global]} )) || return
		_p9k__ret= 
		if [[ $JENV_DIR != (|.) ]]
		then
			[[ $JENV_DIR == /* ]] && local dir=$JENV_DIR  || local dir="$_p9k__cwd_a/$JENV_DIR" 
			dir=${dir:A} 
			if [[ $dir != $_p9k__cwd_a ]]
			then
				while true
				do
					if _p9k_read_word $dir/.java-version
					then
						(( ${_POWERLEVEL9K_JENV_SOURCES[(I)local]} )) || return
						break
					fi
					[[ $dir == (/|.) ]] && break
					dir=${dir:h} 
				done
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			_p9k_upglob .java-version -.
			local -i idx=$? 
			if (( idx )) && _p9k_read_word $_p9k__parent_dirs[idx]/.java-version
			then
				(( ${_POWERLEVEL9K_JENV_SOURCES[(I)local]} )) || return
			else
				_p9k__ret= 
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			(( _POWERLEVEL9K_JENV_PROMPT_ALWAYS_SHOW )) || return
			(( ${_POWERLEVEL9K_JENV_SOURCES[(I)global]} )) || return
			_p9k_jenv_global_version
		fi
		local v=$_p9k__ret 
	fi
	if (( !_POWERLEVEL9K_JENV_PROMPT_ALWAYS_SHOW ))
	then
		_p9k_jenv_global_version
		[[ $v == $_p9k__ret ]] && return
	fi
	if (( !_POWERLEVEL9K_JENV_SHOW_SYSTEM ))
	then
		[[ $v == system ]] && return
	fi
	_p9k_prompt_segment "$0" white red 'JAVA_ICON' 0 '' "${v//\%/%%}"
}
prompt_kubecontext () {
	if ! _p9k_cache_stat_get $0 ${(s.:.)${KUBECONFIG:-$HOME/.kube/config}}
	then
		local name namespace cluster user cloud_name cloud_account cloud_zone cloud_cluster text state
		() {
			local cfg && cfg=(${(f)"$(kubectl config view -o=yaml 2>/dev/null)"})  || return
			local qstr='"*"' 
			local str='([^"'\''|>]*|'$qstr')' 
			local ctx=(${(@M)cfg:#current-context: $~str}) 
			(( $#ctx == 1 )) || return
			name=${ctx[1]#current-context: } 
			local -i pos=${cfg[(i)contexts:]} 
			{
				(( pos <= $#cfg )) || return
				shift $pos cfg
				pos=${cfg[(i)  name: ${(b)name}]} 
				(( pos <= $#cfg )) || return
				(( --pos ))
				for ((; pos > 0; --pos)) do
					local line=$cfg[pos] 
					if [[ $line == '- context:' ]]
					then
						return 0
					elif [[ $line == (#b)'    cluster: '($~str) ]]
					then
						cluster=$match[1] 
						[[ $cluster == $~qstr ]] && cluster=$cluster[2,-2] 
					elif [[ $line == (#b)'    namespace: '($~str) ]]
					then
						namespace=$match[1] 
						[[ $namespace == $~qstr ]] && namespace=$namespace[2,-2] 
					elif [[ $line == (#b)'    user: '($~str) ]]
					then
						user=$match[1] 
						[[ $user == $~qstr ]] && user=$user[2,-2] 
					fi
				done
			} always {
				[[ $name == $~qstr ]] && name=$name[2,-2] 
			}
		}
		if [[ -n $name ]]
		then
			: ${namespace:=default}
			if [[ $cluster == (#b)gke_(?*)_(asia|australia|europe|northamerica|southamerica|us)-([a-z]##<->)(-[a-z]|)_(?*) ]]
			then
				cloud_name=gke 
				cloud_account=$match[1] 
				cloud_zone=$match[2]-$match[3]$match[4] 
				cloud_cluster=$match[5] 
				if (( ${_POWERLEVEL9K_KUBECONTEXT_SHORTEN[(I)gke]} ))
				then
					text=$cloud_cluster 
				fi
			elif [[ $cluster == (#b)arn:aws[[:alnum:]-]#:eks:([[:alnum:]-]##):([[:digit:]]##):cluster/(?*) ]]
			then
				cloud_name=eks 
				cloud_zone=$match[1] 
				cloud_account=$match[2] 
				cloud_cluster=$match[3] 
				if (( ${_POWERLEVEL9K_KUBECONTEXT_SHORTEN[(I)eks]} ))
				then
					text=$cloud_cluster 
				fi
			fi
			if [[ -z $text ]]
			then
				text=$name 
				if [[ $_POWERLEVEL9K_KUBECONTEXT_SHOW_DEFAULT_NAMESPACE == 1 || $namespace != (default|$name) ]]
				then
					text+="/$namespace" 
				fi
			fi
			local pat class
			for pat class in "${_POWERLEVEL9K_KUBECONTEXT_CLASSES[@]}"
			do
				if [[ $text == ${~pat} ]]
				then
					[[ -n $class ]] && state=_${${(U)class}//İ/I} 
					break
				fi
			done
		fi
		_p9k_cache_stat_set "${(g::)name}" "${(g::)namespace}" "${(g::)cluster}" "${(g::)user}" "${(g::)cloud_name}" "${(g::)cloud_account}" "${(g::)cloud_zone}" "${(g::)cloud_cluster}" "${(g::)text}" "$state"
	fi
	typeset -g P9K_KUBECONTEXT_NAME=$_p9k__cache_val[1] 
	typeset -g P9K_KUBECONTEXT_NAMESPACE=$_p9k__cache_val[2] 
	typeset -g P9K_KUBECONTEXT_CLUSTER=$_p9k__cache_val[3] 
	typeset -g P9K_KUBECONTEXT_USER=$_p9k__cache_val[4] 
	typeset -g P9K_KUBECONTEXT_CLOUD_NAME=$_p9k__cache_val[5] 
	typeset -g P9K_KUBECONTEXT_CLOUD_ACCOUNT=$_p9k__cache_val[6] 
	typeset -g P9K_KUBECONTEXT_CLOUD_ZONE=$_p9k__cache_val[7] 
	typeset -g P9K_KUBECONTEXT_CLOUD_CLUSTER=$_p9k__cache_val[8] 
	[[ -n $_p9k__cache_val[9] ]] || return
	_p9k_prompt_segment $0$_p9k__cache_val[10] magenta white KUBERNETES_ICON 0 '' "${_p9k__cache_val[9]//\%/%%}"
}
prompt_laravel_version () {
	_p9k_upglob artisan && return
	local dir=$_p9k__parent_dirs[$?] 
	local app=$dir/vendor/laravel/framework/src/Illuminate/Foundation/Application.php 
	[[ -r $app ]] || return
	if ! _p9k_cache_stat_get $0 $dir/artisan $app
	then
		local v="$(php $dir/artisan --version 2> /dev/null)" 
		v="${${(M)v:#Laravel Framework *}#Laravel Framework }" 
		v=${${v#$'\e['<->m}%$'\e['<->m} 
		_p9k_cache_stat_set "$v"
	fi
	[[ -n $_p9k__cache_val[1] ]] || return
	_p9k_prompt_segment "$0" "maroon" "white" 'LARAVEL_ICON' 0 '' "${_p9k__cache_val[1]//\%/%%}"
}
prompt_lf () {
	_p9k_prompt_segment $0 6 $_p9k_color1 LF_ICON 0 '' $LF_LEVEL
}
prompt_load () {
	if [[ $_p9k_os == (OSX|BSD) ]]
	then
		local -i len=$#_p9k__prompt _p9k__has_upglob 
		_p9k_prompt_segment $0_CRITICAL red "$_p9k_color1" LOAD_ICON 1 '$_p9k__load_critical' '$_p9k__load_value'
		_p9k_prompt_segment $0_WARNING yellow "$_p9k_color1" LOAD_ICON 1 '$_p9k__load_warning' '$_p9k__load_value'
		_p9k_prompt_segment $0_NORMAL green "$_p9k_color1" LOAD_ICON 1 '$_p9k__load_normal' '$_p9k__load_value'
		(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
		return
	fi
	[[ -r /proc/loadavg ]] || return
	_p9k_read_file /proc/loadavg || return
	local load=${${(A)=_p9k__ret}[_POWERLEVEL9K_LOAD_WHICH]//,/.} 
	local -F pct='100. * load / _p9k_num_cpus' 
	if (( pct > _POWERLEVEL9K_LOAD_CRITICAL_PCT ))
	then
		_p9k_prompt_segment $0_CRITICAL red "$_p9k_color1" LOAD_ICON 0 '' $load
	elif (( pct > _POWERLEVEL9K_LOAD_WARNING_PCT ))
	then
		_p9k_prompt_segment $0_WARNING yellow "$_p9k_color1" LOAD_ICON 0 '' $load
	else
		_p9k_prompt_segment $0_NORMAL green "$_p9k_color1" LOAD_ICON 0 '' $load
	fi
}
prompt_luaenv () {
	if [[ -n $LUAENV_VERSION ]]
	then
		(( ${_POWERLEVEL9K_LUAENV_SOURCES[(I)shell]} )) || return
		local v=$LUAENV_VERSION 
	else
		(( ${_POWERLEVEL9K_LUAENV_SOURCES[(I)local|global]} )) || return
		_p9k__ret= 
		if [[ $LUAENV_DIR != (|.) ]]
		then
			[[ $LUAENV_DIR == /* ]] && local dir=$LUAENV_DIR  || local dir="$_p9k__cwd_a/$LUAENV_DIR" 
			dir=${dir:A} 
			if [[ $dir != $_p9k__cwd_a ]]
			then
				while true
				do
					if _p9k_read_word $dir/.lua-version
					then
						(( ${_POWERLEVEL9K_LUAENV_SOURCES[(I)local]} )) || return
						break
					fi
					[[ $dir == (/|.) ]] && break
					dir=${dir:h} 
				done
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			_p9k_upglob .lua-version -.
			local -i idx=$? 
			if (( idx )) && _p9k_read_word $_p9k__parent_dirs[idx]/.lua-version
			then
				(( ${_POWERLEVEL9K_LUAENV_SOURCES[(I)local]} )) || return
			else
				_p9k__ret= 
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			(( _POWERLEVEL9K_LUAENV_PROMPT_ALWAYS_SHOW )) || return
			(( ${_POWERLEVEL9K_LUAENV_SOURCES[(I)global]} )) || return
			_p9k_luaenv_global_version
		fi
		local v=$_p9k__ret 
	fi
	if (( !_POWERLEVEL9K_LUAENV_PROMPT_ALWAYS_SHOW ))
	then
		_p9k_luaenv_global_version
		[[ $v == $_p9k__ret ]] && return
	fi
	if (( !_POWERLEVEL9K_LUAENV_SHOW_SYSTEM ))
	then
		[[ $v == system ]] && return
	fi
	_p9k_prompt_segment "$0" blue "$_p9k_color1" 'LUA_ICON' 0 '' "${v//\%/%%}"
}
prompt_midnight_commander () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment $0 $_p9k_color1 yellow MIDNIGHT_COMMANDER_ICON 0 '' ''
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_nix_shell () {
	_p9k_prompt_segment $0 4 $_p9k_color1 NIX_SHELL_ICON 0 '' "${(M)IN_NIX_SHELL:#(pure|impure)}"
}
prompt_nnn () {
	_p9k_prompt_segment $0 6 $_p9k_color1 NNN_ICON 0 '' $NNNLVL
}
prompt_node_version () {
	_p9k_upglob package.json -.
	local -i idx=$? 
	(( idx || ! _POWERLEVEL9K_NODE_VERSION_PROJECT_ONLY )) || return
	local node=$commands[node] 
	local -a file_deps env_deps
	if [[ $node == ${NODENV_ROOT:-$HOME/.nodenv}/shims/node ]]
	then
		env_deps+=("$NODENV_VERSION") 
		file_deps+=(${NODENV_ROOT:-$HOME/.nodenv}/version) 
		if [[ $NODENV_DIR != (|.) ]]
		then
			[[ $NODENV_DIR == /* ]] && local dir=$NODENV_DIR  || local dir="$_p9k__cwd_a/$NODENV_DIR" 
			dir=${dir:A} 
			if [[ $dir != $_p9k__cwd_a ]]
			then
				while true
				do
					if [[ -e $dir/.node-version ]]
					then
						file_deps+=($dir/.node-version) 
						break
					fi
					[[ $dir == (/|.) ]] && break
					dir=${dir:h} 
				done
			fi
		fi
		_p9k_upglob .node-version -. || file_deps+=($_p9k__parent_dirs[idx]/.node-version) 
	elif (( idx ))
	then
		file_deps+=($_p9k__parent_dirs[idx]/package.json) 
	fi
	if ! _p9k_cache_stat_get "$0 $#env_deps ${(j: :)${(@q)env_deps}} ${(j: :)${(@q)file_deps}}" $file_deps $node
	then
		local out
		out=$($node --version 2>/dev/null) 
		_p9k_cache_stat_set $(( ! $? )) "$out"
	fi
	(( $_p9k__cache_val[1] )) || return
	local v=$_p9k__cache_val[2] 
	[[ $v == v?* ]] || return
	_p9k_prompt_segment "$0" "green" "white" 'NODE_ICON' 0 '' "${${v#v}//\%/%%}"
}
prompt_nodeenv () {
	local msg
	if (( _POWERLEVEL9K_NODEENV_SHOW_NODE_VERSION )) && _p9k_cached_cmd 0 '' node --version
	then
		msg="${_p9k__ret//\%/%%} " 
	fi
	msg+="$_POWERLEVEL9K_NODEENV_LEFT_DELIMITER${${NODE_VIRTUAL_ENV:t}//\%/%%}$_POWERLEVEL9K_NODEENV_RIGHT_DELIMITER" 
	_p9k_prompt_segment "$0" "black" "green" 'NODE_ICON' 0 '' "$msg"
}
prompt_nodenv () {
	if [[ -n $NODENV_VERSION ]]
	then
		(( ${_POWERLEVEL9K_NODENV_SOURCES[(I)shell]} )) || return
		local v=$NODENV_VERSION 
	else
		(( ${_POWERLEVEL9K_NODENV_SOURCES[(I)local|global]} )) || return
		_p9k__ret= 
		if [[ $NODENV_DIR != (|.) ]]
		then
			[[ $NODENV_DIR == /* ]] && local dir=$NODENV_DIR  || local dir="$_p9k__cwd_a/$NODENV_DIR" 
			dir=${dir:A} 
			if [[ $dir != $_p9k__cwd_a ]]
			then
				while true
				do
					if _p9k_read_word $dir/.node-version
					then
						(( ${_POWERLEVEL9K_NODENV_SOURCES[(I)local]} )) || return
						break
					fi
					[[ $dir == (/|.) ]] && break
					dir=${dir:h} 
				done
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			_p9k_upglob .node-version -.
			local -i idx=$? 
			if (( idx )) && _p9k_read_word $_p9k__parent_dirs[idx]/.node-version
			then
				(( ${_POWERLEVEL9K_NODENV_SOURCES[(I)local]} )) || return
			else
				_p9k__ret= 
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			(( _POWERLEVEL9K_NODENV_PROMPT_ALWAYS_SHOW )) || return
			(( ${_POWERLEVEL9K_NODENV_SOURCES[(I)global]} )) || return
			_p9k_nodenv_global_version
		fi
		_p9k_nodeenv_version_transform $_p9k__ret || return
		local v=$_p9k__ret 
	fi
	if (( !_POWERLEVEL9K_NODENV_PROMPT_ALWAYS_SHOW ))
	then
		_p9k_nodenv_global_version
		_p9k_nodeenv_version_transform $_p9k__ret && [[ $v == $_p9k__ret ]] && return
	fi
	if (( !_POWERLEVEL9K_NODENV_SHOW_SYSTEM ))
	then
		[[ $v == system ]] && return
	fi
	_p9k_prompt_segment "$0" "black" "green" 'NODE_ICON' 0 '' "${v//\%/%%}"
}
prompt_nordvpn () {
	unset $__p9k_nordvpn_tag P9K_NORDVPN_COUNTRY_CODE
	[[ -e /run/nordvpn/nordvpnd.sock ]] || return
	_p9k_fetch_nordvpn_status 2> /dev/null || return
	if [[ $P9K_NORDVPN_SERVER == (#b)([[:alpha:]]##)[[:digit:]]##.nordvpn.com ]]
	then
		typeset -g P9K_NORDVPN_COUNTRY_CODE=${${(U)match[1]}//İ/I} 
	fi
	case $P9K_NORDVPN_STATUS in
		(Connected) _p9k_prompt_segment $0_CONNECTED blue white NORDVPN_ICON 0 '' "$P9K_NORDVPN_COUNTRY_CODE" ;;
		(Disconnected | Connecting | Disconnecting) local state=${${(U)P9K_NORDVPN_STATUS}//İ/I} 
			_p9k_get_icon $0_$state FAIL_ICON
			_p9k_prompt_segment $0_$state yellow white NORDVPN_ICON 0 '' "$_p9k__ret" ;;
		(*) return ;;
	esac
}
prompt_nvm () {
	[[ -n $NVM_DIR ]] && _p9k_nvm_ls_current || return
	local current=$_p9k__ret 
	(( _POWERLEVEL9K_NVM_SHOW_SYSTEM )) || [[ $current != system ]] || return
	(( _POWERLEVEL9K_NVM_PROMPT_ALWAYS_SHOW )) || ! _p9k_nvm_ls_default || [[ $_p9k__ret != $current ]] || return
	_p9k_prompt_segment "$0" "magenta" "black" 'NODE_ICON' 0 '' "${${current#v}//\%/%%}"
}
prompt_openfoam () {
	if [[ -z "$WM_FORK" ]]
	then
		_p9k_prompt_segment "$0" "yellow" "$_p9k_color1" '' 0 '' "OF: ${${WM_PROJECT_VERSION:t}//\%/%%}"
	else
		_p9k_prompt_segment "$0" "yellow" "$_p9k_color1" '' 0 '' "F-X: ${${WM_PROJECT_VERSION:t}//\%/%%}"
	fi
}
prompt_os_icon () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment "$0" "black" "white" '' 0 '' "$_p9k_os_icon"
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_package () {
	unset P9K_PACKAGE_NAME P9K_PACKAGE_VERSION
	_p9k_upglob package.json -. && return
	local file=$_p9k__parent_dirs[$?]/package.json 
	if ! _p9k_cache_stat_get $0 $file
	then
		() {
			local data field
			local -A found
			{
				data="$(<$file)"  || return
			} 2> /dev/null
			data=${${data//$'\r'}##[[:space:]]#} 
			[[ $data == '{'* ]] || return
			data[1]= 
			local -i depth=1 
			while true
			do
				data=${data##[[:space:]]#} 
				[[ -n $data ]] || return
				case $data[1] in
					('{' | '[') data[1]= 
						(( ++depth )) ;;
					('}' | ']') data[1]= 
						(( --depth > 0 )) || return ;;
					(':') data[1]=  ;;
					(',') data[1]= 
						field=  ;;
					([[:alnum:].]) data=${data##[[:alnum:].]#}  ;;
					('"') local tail=${data##\"([^\"\\]|\\?)#} 
						[[ $tail == '"'* ]] || return
						local s=${data:1:-$#tail} 
						data=${tail:1} 
						(( depth == 1 )) || continue
						if [[ -z $field ]]
						then
							field=${s:-x} 
						elif [[ $field == (name|version) ]]
						then
							(( ! $+found[$field] )) || return
							[[ -n $s ]] || return
							[[ $s != *($'\n'|'\')* ]] || return
							found[$field]=$s 
							(( $#found == 2 )) && break
						fi ;;
					(*) return 1 ;;
				esac
			done
			_p9k_cache_stat_set 1 $found[name] $found[version]
			return 0
		} || _p9k_cache_stat_set 0
	fi
	(( _p9k__cache_val[1] )) || return
	P9K_PACKAGE_NAME=$_p9k__cache_val[2] 
	P9K_PACKAGE_VERSION=$_p9k__cache_val[3] 
	_p9k_prompt_segment "$0" "cyan" "$_p9k_color1" PACKAGE_ICON 0 '' ${P9K_PACKAGE_VERSION//\%/%%}
}
prompt_per_directory_history () {
	if [[ $_per_directory_history_is_global == true ]]
	then
		_p9k_prompt_segment ${0}_GLOBAL 3 $_p9k_color1 HISTORY_ICON 0 '' global
	else
		_p9k_prompt_segment ${0}_LOCAL 5 $_p9k_color1 HISTORY_ICON 0 '' local
	fi
}
prompt_perlbrew () {
	if (( _POWERLEVEL9K_PERLBREW_PROJECT_ONLY ))
	then
		_p9k_upglob 'cpanfile|.perltidyrc|(|MY)META.(yml|json)|(Makefile|Build).PL|*.(pl|pm|t|pod)' -. && return
	fi
	local v=$PERLBREW_PERL 
	(( _POWERLEVEL9K_PERLBREW_SHOW_PREFIX )) || v=${v#*-} 
	[[ -n $v ]] || return
	_p9k_prompt_segment "$0" "blue" "$_p9k_color1" 'PERL_ICON' 0 '' "${v//\%/%%}"
}
prompt_php_version () {
	if (( _POWERLEVEL9K_PHP_VERSION_PROJECT_ONLY ))
	then
		_p9k_upglob 'composer.json|*.php' -. && return
	fi
	_p9k_cached_cmd 0 '' php --version || return
	[[ $_p9k__ret == (#b)(*$'\n')#'PHP '([[:digit:].]##)* ]] || return
	local v=$match[2] 
	_p9k_prompt_segment "$0" "fuchsia" "grey93" 'PHP_ICON' 0 '' "${v//\%/%%}"
}
prompt_phpenv () {
	if [[ -n $PHPENV_VERSION ]]
	then
		(( ${_POWERLEVEL9K_PHPENV_SOURCES[(I)shell]} )) || return
		local v=$PHPENV_VERSION 
	else
		(( ${_POWERLEVEL9K_PHPENV_SOURCES[(I)local|global]} )) || return
		_p9k__ret= 
		if [[ $PHPENV_DIR != (|.) ]]
		then
			[[ $PHPENV_DIR == /* ]] && local dir=$PHPENV_DIR  || local dir="$_p9k__cwd_a/$PHPENV_DIR" 
			dir=${dir:A} 
			if [[ $dir != $_p9k__cwd_a ]]
			then
				while true
				do
					if _p9k_read_word $dir/.php-version
					then
						(( ${_POWERLEVEL9K_PHPENV_SOURCES[(I)local]} )) || return
						break
					fi
					[[ $dir == (/|.) ]] && break
					dir=${dir:h} 
				done
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			_p9k_upglob .php-version -.
			local -i idx=$? 
			if (( idx )) && _p9k_read_word $_p9k__parent_dirs[idx]/.php-version
			then
				(( ${_POWERLEVEL9K_PHPENV_SOURCES[(I)local]} )) || return
			else
				_p9k__ret= 
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			(( _POWERLEVEL9K_PHPENV_PROMPT_ALWAYS_SHOW )) || return
			(( ${_POWERLEVEL9K_PHPENV_SOURCES[(I)global]} )) || return
			_p9k_phpenv_global_version
		fi
		local v=$_p9k__ret 
	fi
	if (( !_POWERLEVEL9K_PHPENV_PROMPT_ALWAYS_SHOW ))
	then
		_p9k_phpenv_global_version
		[[ $v == $_p9k__ret ]] && return
	fi
	if (( !_POWERLEVEL9K_PHPENV_SHOW_SYSTEM ))
	then
		[[ $v == system ]] && return
	fi
	_p9k_prompt_segment "$0" "magenta" "$_p9k_color1" 'PHP_ICON' 0 '' "${v//\%/%%}"
}
prompt_plenv () {
	if [[ -n $PLENV_VERSION ]]
	then
		(( ${_POWERLEVEL9K_PLENV_SOURCES[(I)shell]} )) || return
		local v=$PLENV_VERSION 
	else
		(( ${_POWERLEVEL9K_PLENV_SOURCES[(I)local|global]} )) || return
		_p9k__ret= 
		if [[ $PLENV_DIR != (|.) ]]
		then
			[[ $PLENV_DIR == /* ]] && local dir=$PLENV_DIR  || local dir="$_p9k__cwd_a/$PLENV_DIR" 
			dir=${dir:A} 
			if [[ $dir != $_p9k__cwd_a ]]
			then
				while true
				do
					if _p9k_read_word $dir/.perl-version
					then
						(( ${_POWERLEVEL9K_PLENV_SOURCES[(I)local]} )) || return
						break
					fi
					[[ $dir == (/|.) ]] && break
					dir=${dir:h} 
				done
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			_p9k_upglob .perl-version -.
			local -i idx=$? 
			if (( idx )) && _p9k_read_word $_p9k__parent_dirs[idx]/.perl-version
			then
				(( ${_POWERLEVEL9K_PLENV_SOURCES[(I)local]} )) || return
			else
				_p9k__ret= 
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			(( _POWERLEVEL9K_PLENV_PROMPT_ALWAYS_SHOW )) || return
			(( ${_POWERLEVEL9K_PLENV_SOURCES[(I)global]} )) || return
			_p9k_plenv_global_version
		fi
		local v=$_p9k__ret 
	fi
	if (( !_POWERLEVEL9K_PLENV_PROMPT_ALWAYS_SHOW ))
	then
		_p9k_plenv_global_version
		[[ $v == $_p9k__ret ]] && return
	fi
	if (( !_POWERLEVEL9K_PLENV_SHOW_SYSTEM ))
	then
		[[ $v == system ]] && return
	fi
	_p9k_prompt_segment "$0" "blue" "$_p9k_color1" 'PERL_ICON' 0 '' "${v//\%/%%}"
}
prompt_powerlevel9k_setup () {
	_p9k_restore_special_params
	eval "$__p9k_intro"
	_p9k_setup
}
prompt_powerlevel9k_teardown () {
	_p9k_restore_special_params
	eval "$__p9k_intro"
	add-zsh-hook -D precmd '(_p9k_|powerlevel9k_)*'
	add-zsh-hook -D preexec '(_p9k_|powerlevel9k_)*'
	PROMPT='%m%# ' 
	RPROMPT= 
	if (( __p9k_enabled ))
	then
		_p9k_deinit
		__p9k_enabled=0 
	fi
}
prompt_prompt_char () {
	local saved=$_p9k__prompt_char_saved[$_p9k__prompt_side$_p9k__segment_index$((!_p9k__status))] 
	if [[ -n $saved ]]
	then
		_p9k__prompt+=$saved 
		return
	fi
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	if (( __p9k_sh_glob ))
	then
		if (( _p9k__status ))
		then
			if (( _POWERLEVEL9K_PROMPT_CHAR_OVERWRITE_STATE ))
			then
				_p9k_prompt_segment $0_ERROR_VIINS "$_p9k_color1" 196 '' 0 '${${${${${${:-$_p9k__keymap.$_p9k__zle_state}:#vicmd.*}:#vivis.*}:#vivli.*}:#*.*overwrite*}}' '❯'
				_p9k_prompt_segment $0_ERROR_VIOWR "$_p9k_color1" 196 '' 0 '${${${${${${:-$_p9k__keymap.$_p9k__zle_state}:#vicmd.*}:#vivis.*}:#vivli.*}:#*.*insert*}}' '▶'
			else
				_p9k_prompt_segment $0_ERROR_VIINS "$_p9k_color1" 196 '' 0 '${${${${_p9k__keymap:#vicmd}:#vivis}:#vivli}}' '❯'
			fi
			_p9k_prompt_segment $0_ERROR_VICMD "$_p9k_color1" 196 '' 0 '${(M)${:-$_p9k__keymap$_p9k__region_active}:#vicmd0}' '❮'
			_p9k_prompt_segment $0_ERROR_VIVIS "$_p9k_color1" 196 '' 0 '${$((! ${#${${${${:-$_p9k__keymap$_p9k__region_active}:#vicmd1}:#vivis?}:#vivli?}})):#0}' 'Ⅴ'
		else
			if (( _POWERLEVEL9K_PROMPT_CHAR_OVERWRITE_STATE ))
			then
				_p9k_prompt_segment $0_OK_VIINS "$_p9k_color1" 76 '' 0 '${${${${${${:-$_p9k__keymap.$_p9k__zle_state}:#vicmd.*}:#vivis.*}:#vivli.*}:#*.*overwrite*}}' '❯'
				_p9k_prompt_segment $0_OK_VIOWR "$_p9k_color1" 76 '' 0 '${${${${${${:-$_p9k__keymap.$_p9k__zle_state}:#vicmd.*}:#vivis.*}:#vivli.*}:#*.*insert*}}' '▶'
			else
				_p9k_prompt_segment $0_OK_VIINS "$_p9k_color1" 76 '' 0 '${${${${_p9k__keymap:#vicmd}:#vivis}:#vivli}}' '❯'
			fi
			_p9k_prompt_segment $0_OK_VICMD "$_p9k_color1" 76 '' 0 '${(M)${:-$_p9k__keymap$_p9k__region_active}:#vicmd0}' '❮'
			_p9k_prompt_segment $0_OK_VIVIS "$_p9k_color1" 76 '' 0 '${$((! ${#${${${${:-$_p9k__keymap$_p9k__region_active}:#vicmd1}:#vivis?}:#vivli?}})):#0}' 'Ⅴ'
		fi
	else
		if (( _p9k__status ))
		then
			if (( _POWERLEVEL9K_PROMPT_CHAR_OVERWRITE_STATE ))
			then
				_p9k_prompt_segment $0_ERROR_VIINS "$_p9k_color1" 196 '' 0 '${${:-$_p9k__keymap.$_p9k__zle_state}:#(vicmd.*|vivis.*|vivli.*|*.*overwrite*)}' '❯'
				_p9k_prompt_segment $0_ERROR_VIOWR "$_p9k_color1" 196 '' 0 '${${:-$_p9k__keymap.$_p9k__zle_state}:#(vicmd.*|vivis.*|vivli.*|*.*insert*)}' '▶'
			else
				_p9k_prompt_segment $0_ERROR_VIINS "$_p9k_color1" 196 '' 0 '${_p9k__keymap:#(vicmd|vivis|vivli)}' '❯'
			fi
			_p9k_prompt_segment $0_ERROR_VICMD "$_p9k_color1" 196 '' 0 '${(M)${:-$_p9k__keymap$_p9k__region_active}:#vicmd0}' '❮'
			_p9k_prompt_segment $0_ERROR_VIVIS "$_p9k_color1" 196 '' 0 '${(M)${:-$_p9k__keymap$_p9k__region_active}:#(vicmd1|vivis?|vivli?)}' 'Ⅴ'
		else
			if (( _POWERLEVEL9K_PROMPT_CHAR_OVERWRITE_STATE ))
			then
				_p9k_prompt_segment $0_OK_VIINS "$_p9k_color1" 76 '' 0 '${${:-$_p9k__keymap.$_p9k__zle_state}:#(vicmd.*|vivis.*|vivli.*|*.*overwrite*)}' '❯'
				_p9k_prompt_segment $0_OK_VIOWR "$_p9k_color1" 76 '' 0 '${${:-$_p9k__keymap.$_p9k__zle_state}:#(vicmd.*|vivis.*|vivli.*|*.*insert*)}' '▶'
			else
				_p9k_prompt_segment $0_OK_VIINS "$_p9k_color1" 76 '' 0 '${_p9k__keymap:#(vicmd|vivis|vivli)}' '❯'
			fi
			_p9k_prompt_segment $0_OK_VICMD "$_p9k_color1" 76 '' 0 '${(M)${:-$_p9k__keymap$_p9k__region_active}:#vicmd0}' '❮'
			_p9k_prompt_segment $0_OK_VIVIS "$_p9k_color1" 76 '' 0 '${(M)${:-$_p9k__keymap$_p9k__region_active}:#(vicmd1|vivis?|vivli?)}' 'Ⅴ'
		fi
	fi
	(( _p9k__has_upglob )) || _p9k__prompt_char_saved[$_p9k__prompt_side$_p9k__segment_index$((!_p9k__status))]=$_p9k__prompt[len+1,-1] 
}
prompt_proxy () {
	local -U p=($all_proxy $http_proxy $https_proxy $ftp_proxy $ALL_PROXY $HTTP_PROXY $HTTPS_PROXY $FTP_PROXY) 
	p=(${(@)${(@)${(@)p#*://}##*@}%%/*}) 
	(( $#p == 1 )) || p=("") 
	_p9k_prompt_segment $0 $_p9k_color1 blue PROXY_ICON 0 '' "$p[1]"
}
prompt_public_ip () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	local ip='${_p9k__public_ip:-$_POWERLEVEL9K_PUBLIC_IP_NONE}' 
	if [[ -n $_POWERLEVEL9K_PUBLIC_IP_VPN_INTERFACE ]]
	then
		_p9k_prompt_segment "$0" "$_p9k_color1" "$_p9k_color2" PUBLIC_IP_ICON 1 '${_p9k__public_ip_not_vpn:+'$ip'}' $ip
		_p9k_prompt_segment "$0" "$_p9k_color1" "$_p9k_color2" VPN_ICON 1 '${_p9k__public_ip_vpn:+'$ip'}' $ip
	else
		_p9k_prompt_segment "$0" "$_p9k_color1" "$_p9k_color2" PUBLIC_IP_ICON 1 $ip $ip
	fi
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_pyenv () {
	_p9k_pyenv_compute || return
	_p9k_prompt_segment "$0" "blue" "$_p9k_color1" 'PYTHON_ICON' 0 '' "${_p9k__pyenv_version//\%/%%}"
}
prompt_ram () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment $0 yellow "$_p9k_color1" RAM_ICON 1 '$_p9k__ram_free' '$_p9k__ram_free'
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_ranger () {
	_p9k_prompt_segment $0 $_p9k_color1 yellow RANGER_ICON 0 '' $RANGER_LEVEL
}
prompt_rbenv () {
	if [[ -n $RBENV_VERSION ]]
	then
		(( ${_POWERLEVEL9K_RBENV_SOURCES[(I)shell]} )) || return
		local v=$RBENV_VERSION 
	else
		(( ${_POWERLEVEL9K_RBENV_SOURCES[(I)local|global]} )) || return
		_p9k__ret= 
		if [[ $RBENV_DIR != (|.) ]]
		then
			[[ $RBENV_DIR == /* ]] && local dir=$RBENV_DIR  || local dir="$_p9k__cwd_a/$RBENV_DIR" 
			dir=${dir:A} 
			if [[ $dir != $_p9k__cwd_a ]]
			then
				while true
				do
					if _p9k_read_word $dir/.ruby-version
					then
						(( ${_POWERLEVEL9K_RBENV_SOURCES[(I)local]} )) || return
						break
					fi
					[[ $dir == (/|.) ]] && break
					dir=${dir:h} 
				done
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			_p9k_upglob .ruby-version -.
			local -i idx=$? 
			if (( idx )) && _p9k_read_word $_p9k__parent_dirs[idx]/.ruby-version
			then
				(( ${_POWERLEVEL9K_RBENV_SOURCES[(I)local]} )) || return
			else
				_p9k__ret= 
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			(( _POWERLEVEL9K_RBENV_PROMPT_ALWAYS_SHOW )) || return
			(( ${_POWERLEVEL9K_RBENV_SOURCES[(I)global]} )) || return
			_p9k_rbenv_global_version
		fi
		local v=$_p9k__ret 
	fi
	if (( !_POWERLEVEL9K_RBENV_PROMPT_ALWAYS_SHOW ))
	then
		_p9k_rbenv_global_version
		[[ $v == $_p9k__ret ]] && return
	fi
	if (( !_POWERLEVEL9K_RBENV_SHOW_SYSTEM ))
	then
		[[ $v == system ]] && return
	fi
	_p9k_prompt_segment "$0" "red" "$_p9k_color1" 'RUBY_ICON' 0 '' "${v//\%/%%}"
}
prompt_root_indicator () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment "$0" "$_p9k_color1" "yellow" 'ROOT_ICON' 0 '${${(%):-%#}:#\%}' ''
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_rspec_stats () {
	if [[ -d app && -d spec ]]
	then
		local -a code=(app/**/*.rb(N)) 
		(( $#code )) || return
		local tests=(spec/**/*.rb(N)) 
		_p9k_build_test_stats "$0" "$#code" "$#tests" "RSpec" 'TEST_ICON'
	fi
}
prompt_rust_version () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment $0 darkorange $_p9k_color1 RUST_ICON 1 '$P9K_RUST_VERSION' '${P9K_RUST_VERSION//\%/%%}'
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_rvm () {
	[[ $GEM_HOME == *rvm* && $ruby_string != $rvm_path/bin/ruby ]] || return
	local v=${GEM_HOME:t} 
	(( _POWERLEVEL9K_RVM_SHOW_GEMSET )) || v=${v%%${rvm_gemset_separator:-@}*} 
	(( _POWERLEVEL9K_RVM_SHOW_PREFIX )) || v=${v#*-} 
	[[ -n $v ]] || return
	_p9k_prompt_segment "$0" "240" "$_p9k_color1" 'RUBY_ICON' 0 '' "${v//\%/%%}"
}
prompt_scalaenv () {
	if [[ -n $SCALAENV_VERSION ]]
	then
		(( ${_POWERLEVEL9K_SCALAENV_SOURCES[(I)shell]} )) || return
		local v=$SCALAENV_VERSION 
	else
		(( ${_POWERLEVEL9K_SCALAENV_SOURCES[(I)local|global]} )) || return
		_p9k__ret= 
		if [[ $SCALAENV_DIR != (|.) ]]
		then
			[[ $SCALAENV_DIR == /* ]] && local dir=$SCALAENV_DIR  || local dir="$_p9k__cwd_a/$SCALAENV_DIR" 
			dir=${dir:A} 
			if [[ $dir != $_p9k__cwd_a ]]
			then
				while true
				do
					if _p9k_read_word $dir/.scala-version
					then
						(( ${_POWERLEVEL9K_SCALAENV_SOURCES[(I)local]} )) || return
						break
					fi
					[[ $dir == (/|.) ]] && break
					dir=${dir:h} 
				done
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			_p9k_upglob .scala-version -.
			local -i idx=$? 
			if (( idx )) && _p9k_read_word $_p9k__parent_dirs[idx]/.scala-version
			then
				(( ${_POWERLEVEL9K_SCALAENV_SOURCES[(I)local]} )) || return
			else
				_p9k__ret= 
			fi
		fi
		if [[ -z $_p9k__ret ]]
		then
			(( _POWERLEVEL9K_SCALAENV_PROMPT_ALWAYS_SHOW )) || return
			(( ${_POWERLEVEL9K_SCALAENV_SOURCES[(I)global]} )) || return
			_p9k_scalaenv_global_version
		fi
		local v=$_p9k__ret 
	fi
	if (( !_POWERLEVEL9K_SCALAENV_PROMPT_ALWAYS_SHOW ))
	then
		_p9k_scalaenv_global_version
		[[ $v == $_p9k__ret ]] && return
	fi
	if (( !_POWERLEVEL9K_SCALAENV_SHOW_SYSTEM ))
	then
		[[ $v == system ]] && return
	fi
	_p9k_prompt_segment "$0" "red" "$_p9k_color1" 'SCALA_ICON' 0 '' "${v//\%/%%}"
}
prompt_ssh () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment "$0" "$_p9k_color1" "yellow" 'SSH_ICON' 0 '' ''
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_status () {
	if ! _p9k_cache_get $0 $_p9k__status $_p9k__pipestatus
	then
		(( _p9k__status )) && local state=ERROR  || local state=OK 
		if (( _POWERLEVEL9K_STATUS_EXTENDED_STATES ))
		then
			if (( _p9k__status ))
			then
				if (( $#_p9k__pipestatus > 1 ))
				then
					state+=_PIPE 
				elif (( _p9k__status > 128 ))
				then
					state+=_SIGNAL 
				fi
			elif [[ "$_p9k__pipestatus" == *[1-9]* ]]
			then
				state+=_PIPE 
			fi
		fi
		_p9k__cache_val=(:) 
		if (( _POWERLEVEL9K_STATUS_$state ))
		then
			if (( _POWERLEVEL9K_STATUS_SHOW_PIPESTATUS ))
			then
				local text=${(j:|:)${(@)_p9k__pipestatus:/(#b)(*)/$_p9k_exitcode2str[$match[1]+1]}} 
			else
				local text=$_p9k_exitcode2str[_p9k__status+1] 
			fi
			if (( _p9k__status ))
			then
				if (( !_POWERLEVEL9K_STATUS_CROSS && _POWERLEVEL9K_STATUS_VERBOSE ))
				then
					_p9k__cache_val=($0_$state red yellow1 CARRIAGE_RETURN_ICON 0 '' "$text") 
				else
					_p9k__cache_val=($0_$state $_p9k_color1 red FAIL_ICON 0 '' '') 
				fi
			elif (( _POWERLEVEL9K_STATUS_VERBOSE || _POWERLEVEL9K_STATUS_OK_IN_NON_VERBOSE ))
			then
				[[ $state == OK ]] && text='' 
				_p9k__cache_val=($0_$state "$_p9k_color1" green OK_ICON 0 '' "$text") 
			fi
		fi
		if (( $#_p9k__pipestatus < 3 ))
		then
			_p9k_cache_set "${(@)_p9k__cache_val}"
		fi
	fi
	_p9k_prompt_segment "${(@)_p9k__cache_val}"
}
prompt_swap () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment $0 yellow "$_p9k_color1" SWAP_ICON 1 '$_p9k__swap_used' '$_p9k__swap_used'
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_swift_version () {
	_p9k_cached_cmd 0 '' swift --version || return
	[[ $_p9k__ret == (#b)[^[:digit:]]#([[:digit:].]##)* ]] || return
	_p9k_prompt_segment "$0" "magenta" "white" 'SWIFT_ICON' 0 '' "${match[1]//\%/%%}"
}
prompt_symfony2_tests () {
	if [[ -d src && -d app && -f app/AppKernel.php ]]
	then
		local -a all=(src/**/*.php(N)) 
		local -a code=(${(@)all##*Tests*}) 
		(( $#code )) || return
		_p9k_build_test_stats "$0" "$#code" "$(($#all - $#code))" "SF2" 'TEST_ICON'
	fi
}
prompt_symfony2_version () {
	if [[ -r app/bootstrap.php.cache ]]
	then
		local v="${$(grep -F " VERSION " app/bootstrap.php.cache 2>/dev/null)//[![:digit:].]}" 
		_p9k_prompt_segment "$0" "grey35" "$_p9k_color1" 'SYMFONY_ICON' 0 '' "${v//\%/%%}"
	fi
}
prompt_taskwarrior () {
	unset P9K_TASKWARRIOR_PENDING_COUNT P9K_TASKWARRIOR_OVERDUE_COUNT
	if ! _p9k_taskwarrior_check_data
	then
		_p9k_taskwarrior_data_files=() 
		_p9k_taskwarrior_data_non_files=() 
		_p9k_taskwarrior_data_sig= 
		_p9k_taskwarrior_counters=() 
		_p9k_taskwarrior_next_due=0 
		_p9k_taskwarrior_check_meta || _p9k_taskwarrior_init_meta || return
		_p9k_taskwarrior_init_data
	fi
	(( $#_p9k_taskwarrior_counters )) || return
	local text c=$_p9k_taskwarrior_counters[OVERDUE] 
	if [[ -n $c ]]
	then
		typeset -g P9K_TASKWARRIOR_OVERDUE_COUNT=$c 
		text+="!$c" 
	fi
	c=$_p9k_taskwarrior_counters[PENDING] 
	if [[ -n $c ]]
	then
		typeset -g P9K_TASKWARRIOR_PENDING_COUNT=$c 
		[[ -n $text ]] && text+='/' 
		text+=$c 
	fi
	[[ -n $text ]] || return
	_p9k_prompt_segment $0 6 $_p9k_color1 TASKWARRIOR_ICON 0 '' $text
}
prompt_terraform () {
	local ws=$TF_WORKSPACE 
	if [[ -z $TF_WORKSPACE ]]
	then
		_p9k_read_word ${${TF_DATA_DIR:-.terraform}:A}/environment && ws=$_p9k__ret 
	fi
	[[ -z $ws || ( $ws == default && $_POWERLEVEL9K_TERRAFORM_SHOW_DEFAULT == 0 ) ]] && return
	local pat class state
	for pat class in "${_POWERLEVEL9K_TERRAFORM_CLASSES[@]}"
	do
		if [[ $ws == ${~pat} ]]
		then
			[[ -n $class ]] && state=_${${(U)class}//İ/I} 
			break
		fi
	done
	_p9k_prompt_segment "$0$state" $_p9k_color1 blue TERRAFORM_ICON 0 '' $ws
}
prompt_terraform_version () {
	local v cfg terraform=${commands[terraform]} 
	_p9k_upglob .terraform-version -. || cfg=$_p9k__parent_dirs[$?]/.terraform-version 
	if _p9k_cache_stat_get $0.$TFENV_TERRAFORM_VERSION $terraform $cfg
	then
		v=$_p9k__cache_val[1] 
	else
		v=${${"$(terraform --version 2>/dev/null)"#Terraform v}%%$'\n'*}  || v= 
		_p9k_cache_stat_set "$v"
	fi
	[[ -n $v ]] || return
	_p9k_prompt_segment $0 $_p9k_color1 blue TERRAFORM_ICON 0 '' ${v//\%/%%}
}
prompt_time () {
	if (( _POWERLEVEL9K_EXPERIMENTAL_TIME_REALTIME ))
	then
		_p9k_prompt_segment "$0" "$_p9k_color2" "$_p9k_color1" "TIME_ICON" 0 '' "$_POWERLEVEL9K_TIME_FORMAT"
	else
		if [[ $_p9k__refresh_reason == precmd ]]
		then
			if [[ $+__p9k_instant_prompt_active == 1 && $__p9k_instant_prompt_time_format == $_POWERLEVEL9K_TIME_FORMAT ]]
			then
				_p9k__time=${__p9k_instant_prompt_time//\%/%%} 
			else
				_p9k__time=${${(%)_POWERLEVEL9K_TIME_FORMAT}//\%/%%} 
			fi
		fi
		if (( _POWERLEVEL9K_TIME_UPDATE_ON_COMMAND ))
		then
			_p9k_escape $_p9k__time
			local t=$_p9k__ret 
			_p9k_escape $_POWERLEVEL9K_TIME_FORMAT
			_p9k_prompt_segment "$0" "$_p9k_color2" "$_p9k_color1" "TIME_ICON" 1 '' "\${_p9k__line_finished-$t}\${_p9k__line_finished+$_p9k__ret}"
		else
			_p9k_prompt_segment "$0" "$_p9k_color2" "$_p9k_color1" "TIME_ICON" 0 '' $_p9k__time
		fi
	fi
}
prompt_timewarrior () {
	local dir
	[[ -n ${dir::=$TIMEWARRIORDB} || -n ${dir::=~/.timewarrior}(#q-/N) ]] || dir=${XDG_DATA_HOME:-~/.local/share}/timewarrior 
	dir+=/data 
	local -a stat
	[[ $dir == $_p9k_timewarrior_dir ]] || _p9k_timewarrior_clear
	if [[ -n $_p9k_timewarrior_file_name ]]
	then
		zstat -A stat +mtime -- $dir $_p9k_timewarrior_file_name 2> /dev/null || stat=() 
		if [[ $stat[1] == $_p9k_timewarrior_dir_mtime && $stat[2] == $_p9k_timewarrior_file_mtime ]]
		then
			if (( $+_p9k_timewarrior_tags ))
			then
				_p9k_prompt_segment $0 grey 255 TIMEWARRIOR_ICON 0 '' "${_p9k_timewarrior_tags//\%/%%}"
			fi
			return
		fi
	fi
	if [[ ! -d $dir ]]
	then
		_p9k_timewarrior_clear
		return
	fi
	_p9k_timewarrior_dir=$dir 
	if [[ $stat[1] != $_p9k_timewarrior_dir_mtime ]]
	then
		local -a files=($dir/<->-<->.data(.N)) 
		if (( ! $#files ))
		then
			if (( $#stat )) || zstat -A stat +mtime -- $dir 2> /dev/null
			then
				_p9k_timewarrior_dir_mtime=$stat[1] 
				_p9k_timewarrior_file_mtime=$stat[1] 
				_p9k_timewarrior_file_name=$dir 
				unset _p9k_timewarrior_tags
				_p9k__state_dump_scheduled=1 
			else
				_p9k_timewarrior_clear
			fi
			return
		fi
		_p9k_timewarrior_file_name=${${(AO)files}[1]} 
	fi
	if ! zstat -A stat +mtime -- $dir $_p9k_timewarrior_file_name 2> /dev/null
	then
		_p9k_timewarrior_clear
		return
	fi
	_p9k_timewarrior_dir_mtime=$stat[1] 
	_p9k_timewarrior_file_mtime=$stat[2] 
	{
		local tail=${${(Af)"$(<$_p9k_timewarrior_file_name)"}[-1]} 
	} 2> /dev/null
	if [[ $tail == (#b)'inc '[^\ ]##(|\ #\#(*)) ]]
	then
		_p9k_timewarrior_tags=${${match[2]## #}%% #} 
		_p9k_prompt_segment $0 grey 255 TIMEWARRIOR_ICON 0 '' "${_p9k_timewarrior_tags//\%/%%}"
	else
		unset _p9k_timewarrior_tags
	fi
	_p9k__state_dump_scheduled=1 
}
prompt_todo () {
	unset P9K_TODO_TOTAL_TASK_COUNT P9K_TODO_FILTERED_TASK_COUNT
	[[ -r $_p9k__todo_file && -x $_p9k__todo_command ]] || return
	if ! _p9k_cache_stat_get $0 $_p9k__todo_file
	then
		local count="$($_p9k__todo_command -p ls | command tail -1)" 
		if [[ $count == (#b)'TODO: '([[:digit:]]##)' of '([[:digit:]]##)' '* ]]
		then
			_p9k_cache_stat_set 1 $match[1] $match[2]
		else
			_p9k_cache_stat_set 0
		fi
	fi
	(( $_p9k__cache_val[1] )) || return
	typeset -gi P9K_TODO_FILTERED_TASK_COUNT=$_p9k__cache_val[2] 
	typeset -gi P9K_TODO_TOTAL_TASK_COUNT=$_p9k__cache_val[3] 
	if (( (P9K_TODO_TOTAL_TASK_COUNT    || !_POWERLEVEL9K_TODO_HIDE_ZERO_TOTAL) &&
        (P9K_TODO_FILTERED_TASK_COUNT || !_POWERLEVEL9K_TODO_HIDE_ZERO_FILTERED) ))
	then
		if (( P9K_TODO_TOTAL_TASK_COUNT == P9K_TODO_FILTERED_TASK_COUNT ))
		then
			local text=$P9K_TODO_TOTAL_TASK_COUNT 
		else
			local text="$P9K_TODO_FILTERED_TASK_COUNT/$P9K_TODO_TOTAL_TASK_COUNT" 
		fi
		_p9k_prompt_segment "$0" "grey50" "$_p9k_color1" 'TODO_ICON' 0 '' "$text"
	fi
}
prompt_toolbox () {
	_p9k_prompt_segment $0 $_p9k_color1 yellow TOOLBOX_ICON 0 '' $P9K_TOOLBOX_NAME
}
prompt_user () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment "${0}_ROOT" "${_p9k_color1}" yellow ROOT_ICON 0 '${${(%):-%#}:#\%}' "$_POWERLEVEL9K_USER_TEMPLATE"
	if [[ -n "$SUDO_COMMAND" ]]
	then
		_p9k_prompt_segment "${0}_SUDO" "${_p9k_color1}" yellow SUDO_ICON 0 '${${(%):-%#}:#\#}' "$_POWERLEVEL9K_USER_TEMPLATE"
	else
		_p9k_prompt_segment "${0}_DEFAULT" "${_p9k_color1}" yellow USER_ICON 0 '${${(%):-%#}:#\#}' "%n"
	fi
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_vcs () {
	if (( _p9k_vcs_index && $+GITSTATUS_DAEMON_PID_POWERLEVEL9K ))
	then
		_p9k__prompt+='${(e)_p9k__vcs}' 
		return
	fi
	local -a backends=($_POWERLEVEL9K_VCS_BACKENDS) 
	if (( ${backends[(I)git]} && $+GITSTATUS_DAEMON_PID_POWERLEVEL9K )) && _p9k_vcs_gitstatus
	then
		_p9k_vcs_render && return
		backends=(${backends:#git}) 
	fi
	if (( $#backends ))
	then
		VCS_WORKDIR_DIRTY=false 
		VCS_WORKDIR_HALF_DIRTY=false 
		local current_state="" 
		zstyle ':vcs_info:*' enable ${backends}
		vcs_info
		local vcs_prompt="${vcs_info_msg_0_}" 
		if [[ -n "$vcs_prompt" ]]
		then
			if [[ "$VCS_WORKDIR_DIRTY" == true ]]
			then
				current_state='MODIFIED' 
			else
				if [[ "$VCS_WORKDIR_HALF_DIRTY" == true ]]
				then
					current_state='UNTRACKED' 
				else
					current_state='CLEAN' 
				fi
			fi
			_p9k_prompt_segment "${0}_${${(U)current_state}//İ/I}" "${__p9k_vcs_states[$current_state]}" "$_p9k_color1" "$vcs_visual_identifier" 0 '' "$vcs_prompt"
		fi
	fi
}
prompt_vi_mode () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	if (( __p9k_sh_glob ))
	then
		if (( $+_POWERLEVEL9K_VI_OVERWRITE_MODE_STRING ))
		then
			if [[ -n $_POWERLEVEL9K_VI_INSERT_MODE_STRING ]]
			then
				_p9k_prompt_segment $0_INSERT "$_p9k_color1" blue '' 0 '${${${${${${:-$_p9k__keymap.$_p9k__zle_state}:#vicmd.*}:#vivis.*}:#vivli.*}:#*.*overwrite*}}' "$_POWERLEVEL9K_VI_INSERT_MODE_STRING"
			fi
			_p9k_prompt_segment $0_OVERWRITE "$_p9k_color1" blue '' 0 '${${${${${${:-$_p9k__keymap.$_p9k__zle_state}:#vicmd.*}:#vivis.*}:#vivli.*}:#*.*insert*}}' "$_POWERLEVEL9K_VI_OVERWRITE_MODE_STRING"
		else
			if [[ -n $_POWERLEVEL9K_VI_INSERT_MODE_STRING ]]
			then
				_p9k_prompt_segment $0_INSERT "$_p9k_color1" blue '' 0 '${${${${_p9k__keymap:#vicmd}:#vivis}:#vivli}}' "$_POWERLEVEL9K_VI_INSERT_MODE_STRING"
			fi
		fi
		if (( $+_POWERLEVEL9K_VI_VISUAL_MODE_STRING ))
		then
			_p9k_prompt_segment $0_NORMAL "$_p9k_color1" white '' 0 '${(M)${:-$_p9k__keymap$_p9k__region_active}:#vicmd0}' "$_POWERLEVEL9K_VI_COMMAND_MODE_STRING"
			_p9k_prompt_segment $0_VISUAL "$_p9k_color1" white '' 0 '${$((! ${#${${${${:-$_p9k__keymap$_p9k__region_active}:#vicmd1}:#vivis?}:#vivli?}})):#0}' "$_POWERLEVEL9K_VI_VISUAL_MODE_STRING"
		else
			_p9k_prompt_segment $0_NORMAL "$_p9k_color1" white '' 0 '${$((! ${#${${${_p9k__keymap:#vicmd}:#vivis}:#vivli}})):#0}' "$_POWERLEVEL9K_VI_COMMAND_MODE_STRING"
		fi
	else
		if (( $+_POWERLEVEL9K_VI_OVERWRITE_MODE_STRING ))
		then
			if [[ -n $_POWERLEVEL9K_VI_INSERT_MODE_STRING ]]
			then
				_p9k_prompt_segment $0_INSERT "$_p9k_color1" blue '' 0 '${${:-$_p9k__keymap.$_p9k__zle_state}:#(vicmd.*|vivis.*|vivli.*|*.*overwrite*)}' "$_POWERLEVEL9K_VI_INSERT_MODE_STRING"
			fi
			_p9k_prompt_segment $0_OVERWRITE "$_p9k_color1" blue '' 0 '${${:-$_p9k__keymap.$_p9k__zle_state}:#(vicmd.*|vivis.*|vivli.*|*.*insert*)}' "$_POWERLEVEL9K_VI_OVERWRITE_MODE_STRING"
		else
			if [[ -n $_POWERLEVEL9K_VI_INSERT_MODE_STRING ]]
			then
				_p9k_prompt_segment $0_INSERT "$_p9k_color1" blue '' 0 '${_p9k__keymap:#(vicmd|vivis|vivli)}' "$_POWERLEVEL9K_VI_INSERT_MODE_STRING"
			fi
		fi
		if (( $+_POWERLEVEL9K_VI_VISUAL_MODE_STRING ))
		then
			_p9k_prompt_segment $0_NORMAL "$_p9k_color1" white '' 0 '${(M)${:-$_p9k__keymap$_p9k__region_active}:#vicmd0}' "$_POWERLEVEL9K_VI_COMMAND_MODE_STRING"
			_p9k_prompt_segment $0_VISUAL "$_p9k_color1" white '' 0 '${(M)${:-$_p9k__keymap$_p9k__region_active}:#(vicmd1|vivis?|vivli?)}' "$_POWERLEVEL9K_VI_VISUAL_MODE_STRING"
		else
			_p9k_prompt_segment $0_NORMAL "$_p9k_color1" white '' 0 '${(M)_p9k__keymap:#(vicmd|vivis|vivli)}' "$_POWERLEVEL9K_VI_COMMAND_MODE_STRING"
		fi
	fi
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_vim_shell () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment $0 green $_p9k_color1 VIM_ICON 0 '' ''
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_virtualenv () {
	local msg='' 
	if (( _POWERLEVEL9K_VIRTUALENV_SHOW_PYTHON_VERSION )) && _p9k_python_version
	then
		msg="${_p9k__ret//\%/%%} " 
	fi
	local cfg=$VIRTUAL_ENV/pyvenv.cfg 
	if ! _p9k_cache_stat_get $0 $cfg
	then
		local -a reply
		_p9k_parse_virtualenv_cfg $cfg
		_p9k_cache_stat_set "${reply[@]}"
	fi
	if (( _p9k__cache_val[1] ))
	then
		local v=$_p9k__cache_val[2] 
	else
		local v=${VIRTUAL_ENV:t} 
		if [[ $VIRTUAL_ENV_PROMPT == '('?*') ' && $VIRTUAL_ENV_PROMPT != "($v) " ]]
		then
			v=$VIRTUAL_ENV_PROMPT[2,-3] 
		elif [[ $v == $~_POWERLEVEL9K_VIRTUALENV_GENERIC_NAMES ]]
		then
			v=${VIRTUAL_ENV:h:t} 
		fi
	fi
	msg+="$_POWERLEVEL9K_VIRTUALENV_LEFT_DELIMITER${v//\%/%%}$_POWERLEVEL9K_VIRTUALENV_RIGHT_DELIMITER" 
	case $_POWERLEVEL9K_VIRTUALENV_SHOW_WITH_PYENV in
		(false) _p9k_prompt_segment "$0" "blue" "$_p9k_color1" 'PYTHON_ICON' 0 '${(M)${#P9K_PYENV_PYTHON_VERSION}:#0}' "$msg" ;;
		(if-different) _p9k_escape $v
			_p9k_prompt_segment "$0" "blue" "$_p9k_color1" 'PYTHON_ICON' 0 '${${:-'$_p9k__ret'}:#$_p9k__pyenv_version}' "$msg" ;;
		(*) _p9k_prompt_segment "$0" "blue" "$_p9k_color1" 'PYTHON_ICON' 0 '' "$msg" ;;
	esac
}
prompt_vpn_ip () {
	typeset -ga _p9k__vpn_ip_segments
	_p9k__vpn_ip_segments+=($_p9k__prompt_side $_p9k__line_index $_p9k__segment_index) 
	local p='${(e)_p9k__vpn_ip_'$_p9k__prompt_side$_p9k__segment_index'}' 
	_p9k__prompt+=$p 
	typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$p
}
prompt_wifi () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment $0 green $_p9k_color1 WIFI_ICON 1 '$_p9k__wifi_on' '$P9K_WIFI_LAST_TX_RATE Mbps'
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_xplr () {
	local -i len=$#_p9k__prompt _p9k__has_upglob 
	_p9k_prompt_segment $0 6 $_p9k_color1 XPLR_ICON 0 '' ''
	(( _p9k__has_upglob )) || typeset -g "_p9k__segment_val_${_p9k__prompt_side}[_p9k__segment_index]"=$_p9k__prompt[len+1,-1]
}
prompt_yazi () {
	_p9k_prompt_segment $0 $_p9k_color1 yellow YAZI_ICON 0 '' $YAZI_LEVEL
}
setup_os_environment () {
	local os_name=$(uname -s) 
	case "$os_name" in
		("Darwin") [[ -x /opt/homebrew/bin/brew ]] && eval "$(/opt/homebrew/bin/brew shellenv)" ;;
		("Linux") [[ -x /home/linuxbrew/.linuxbrew/bin/brew ]] && eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)" ;;
		(*) echo "Warning: Unknown OS ($os_name)" >&2 ;;
	esac
}
take () {
	mkdir -p "$1" && cd "$1"
}
toggle-fzf-tab () {
	emulate -L zsh -o extended_glob
	if (( $+_ftb_orig_widget ))
	then
		disable-fzf-tab
	else
		enable-fzf-tab
	fi
}
y () {
	local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd 
	yazi "$@" --cwd-file="$tmp"
	if cwd="$(command cat -- "$tmp")"  && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]
	then
		builtin cd -- "$cwd"
	fi
	rm -f -- "$tmp"
}
z () {
	__zoxide_z "$@"
}
zi () {
	__zoxide_zi "$@"
}
zi-browse-symbol () {
	local -a fpath
	fpath=("/Users/danielr/.local/share/zinit/zinit.git" "/Users/danielr/.local/share/zinit/completions" "/opt/homebrew/share/zsh/site-functions" "/usr/local/share/zsh/site-functions" "/usr/share/zsh/site-functions" "/usr/share/zsh/5.9/functions") 
	builtin autoload -X -U -z
}
zicdclear () {
	.zinit-compdef-clear -q
}
zicdreplay () {
	.zinit-compdef-replay -q
}
zicompdef () {
	ZINIT_COMPDEF_REPLAY+=("${(j: :)${(q)@}}") 
}
zicompinit () {
	autoload -Uz compinit
	compinit -d ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump} "${(Q@)${(z@)ZINIT[COMPINIT_OPTS]}}"
}
zinit () {
	local -A ICE ZINIT_ICE
	ICE=("${(kv)ZINIT_ICES[@]}") 
	ZINIT_ICE=("${(kv)ICE[@]}") 
	ZINIT_ICES=() 
	integer ___retval ___retval2 ___correct
	local -a match mbegin mend
	local MATCH cmd ___q="\`" ___q2="'" IFS=$' \t\n\0' 
	integer MBEGIN MEND
	match=(${ZINIT_EXTS[(I)z-annex subcommand:$1]}) 
	if (( !${#match} ))
	then
		local -a reply
		local REPLY
	fi
	[[ -o ksharrays ]] && ___correct=1 
	local -A ___opt_map OPTS
	___opt_map=(-q opt_-q,--quiet:"update:[Turn off almost-all messages from the {cmd}update{rst} operation {b-lhi}FOR the objects{rst} which don't have any {b-lhi}new version{rst} available.] *:[Turn off any (or: almost-any) messages from the operation.]" --quiet opt_-q,--quiet -v opt_-v,--verbose:"Turn on more messages from the operation." --verbose opt_-v,--verbose -r opt_-r,--reset:"Reset the repository before updating (or remove the files for single-file snippets and gh-r plugins)." --reset opt_-r,--reset -a opt_-a,--all:"delete:[Delete {hi}all{rst} plugins and snippets.] update:[Update {b-lhi}all{rst} plugins and snippets.]" --all opt_-a,--all -c opt_-c,--clean:"Delete {b-lhi}only{rst} the {b-lhi}currently-not loaded{rst} plugins and snippets." --clean opt_-c,--clean -y opt_-y,--yes:"Automatically confirm any yes/no prompts." --yes opt_-y,--yes -f opt_-f,--force:"Force new download of the snippet file." --force opt_-f,--force -p opt_-p,--parallel:"Turn on concurrent, multi-thread update (of all objects)." --parallel opt_-p,--parallel -s opt_-s,--snippets:"snippets:[Update only snippets (i.e.: skip updating plugins).] times:[Show times in seconds instead of milliseconds.]" --snippets opt_-s,--snippets -L opt_-l,--plugins:"Update only plugins (i.e.: skip updating snippets)." --plugins opt_-l,--plugins -h opt_-h,--help:"Show this help message." --help opt_-h,--help -u opt_-u,--urge:"Cause all the hooks like{ehi}:{rst} {ice}atpull{apo}''{rst}, {ice}cp{apo}''{rst}, etc. to execute even when there aren't any new commits {b}/{rst} any new version of the {b}{meta}gh-r{rst} file {b}/{rst} etc.{…} available for download {ehi}{lr}{rst} simulate a non-empty update." --urge opt_-u,--urge -n opt_-n,--no-pager:"Disable the use of the pager." --no-pager opt_-n,--no-pager -m opt_-m,--moments:"Show the {apo}*{b-lhi}moments{apo}*{rst} of object (i.e.: a plugin or snippet) loading time." --moments opt_-m,--moments -b opt_-b,--bindkeys:"Load in light mode, however do still track {cmd}bindkey{rst} calls (to allow remapping the keys bound)." --bindkeys opt_-b,--bindkeys -x opt_-x,--command:"Load the snippet as a {cmd}command{rst}, i.e.: add it to {var}\$PATH{rst} and set {b-lhi}+x{rst} on it." --command opt_-x,--command cdclear "--help|--quiet|-h|-q" cdreplay "--help|--quiet|-h|-q" delete "--all|--clean|--help|--quiet|--yes|-a|-c|-h|-q|-y" env-whitelist "--help|--verbose|-h|-v" light "--help|-b|-h" snippet "--command|--force|--help|-f|-h|-x" times "--help|-h|-m|-s" unload "--help|--quiet|-h|-q" update "--all|--help|--no-pager|--parallel|--plugins|--quiet|--reset|--snippets|--urge|--verbose|-L|-a|-h|-n|-p|-q|-r|-s|-u|-v" version "") 
	cmd="$1" 
	if [[ $cmd == (times|unload|env-whitelist|update|snippet|load|light|cdreplay|cdclear) ]]
	then
		if (( $@[(I)-*] || OPTS[opt_-h,--help] ))
		then
			.zinit-parse-opts "$cmd" "$@"
			if (( OPTS[opt_-h,--help] ))
			then
				+zinit-prehelp-usage-message $cmd $___opt_map[$cmd] $@
				return 1
			fi
		fi
	fi
	reply=(${ZINIT_EXTS[(I)z-annex subcommand:*]}) 
	[[ ( -n $1 && $1 != (${~ZINIT[cmds]}|${(~j:|:)reply[@]#z-annex subcommand:}) ) || $1 = (load|light|snippet) ]] && {
		integer ___error
		if [[ $1 = (load|light|snippet) ]]
		then
			integer ___is_snippet
			() {
				builtin setopt localoptions extendedglob
				: ${@[@]//(#b)([ $'\t']##|(#s))(-b|--command|-f|--force)([ $'\t']##|(#e))/${OPTS[${match[2]}]::=1}}
			} "$@"
			builtin set -- "${@[@]:#(-b|--command|-f|--force)}"
			[[ $1 = light && -z ${OPTS[(I)-b]} ]] && ICE[light-mode]= 
			[[ $1 = snippet ]] && ICE[is-snippet]=  || ___is_snippet=-1 
			shift
			ZINIT_ICES=("${(kv)ICE[@]}") 
			ICE=() ZINIT_ICE=() 
			1="${1:+@}${1#@}${2:+/$2}" 
			(( $# > 1 )) && {
				shift -p $(( $# - 1 ))
			}
			[[ -z $1 ]] && {
				+zi-log "Argument needed, try: {cmd}help."
				return 1
			}
		else
			.zinit-ice "$@"
			___retval2=$? 
			local ___last_ice=${@[___retval2]} 
			shift ___retval2
			if [[ $# -gt 0 && $1 != for ]]
			then
				+zi-log -n "{b}{u-warn}ERROR{b-warn}:{rst} Unknown subcommand{ehi}:" "{apo}\`{cmd}$1{apo}\`{rst} "
				+zinit-prehelp-usage-message rst
				return 1
			elif (( $# == 0 ))
			then
				___error=1 
			else
				shift
			fi
		fi
		integer ___had_wait
		local ___id ___ehid ___etid ___key
		local -a ___arr
		ZINIT[annex-exposed-processed-IDs]= 
		if (( $# ))
		then
			local -a ___ices
			___ices=("${(kv)ZINIT_ICES[@]}") 
			ZINIT_ICES=() 
			while (( $# ))
			do
				.zinit-ice "$@"
				___retval2=$? 
				local ___last_ice=${@[___retval2]} 
				shift ___retval2
				if [[ -n $1 ]]
				then
					ICE=("${___ices[@]}" "${(kv)ZINIT_ICES[@]}") 
					ZINIT_ICE=("${(kv)ICE[@]}") ZINIT_ICES=() 
					integer ___msgs=${+ICE[debug]} 
					(( ___msgs )) && +zi-log "{pre}zinit-main:{faint} Processing {pname}$1{faint}{…}{rst}"
					ZINIT[annex-exposed-processed-IDs]+="${___id:+ $___id}" 
					___id="${${1#@}%%(///|//|/)}" 
					(( ___is_snippet == -1 )) && ___id="${___id#https://github.com/}" 
					___ehid="${ICE[id-as]:-$___id}" 
					___etid="${ICE[teleid]:-$___id}" 
					if (( ${+ICE[pack]} ))
					then
						___had_wait=${+ICE[wait]} 
						.zinit-load-ices "$___ehid"
						[[ $___had_wait -eq 0 ]] && unset 'ICE[wait]'
					fi
					[[ ${ICE[id-as]} = (auto|) && ${+ICE[id-as]} == 1 ]] && ICE[id-as]="${___etid:t}" 
					integer ___is_snippet=${${(M)___is_snippet:#-1}:-0} 
					() {
						builtin setopt localoptions extendedglob
						if [[ $___is_snippet -ge 0 && ( -n ${ICE[is-snippet]+1} || $___etid = ((#i)(http(s|)|ftp(s|)):/|(${(~kj.|.)ZINIT_1MAP}))* ) ]]
						then
							___is_snippet=1 
						fi
					} "$@"
					local ___type=${${${(M)___is_snippet:#1}:+snippet}:-plugin} 
					reply=(${(on)ZINIT_EXTS2[(I)zinit hook:before-load-pre <->]} ${(on)ZINIT_EXTS[(I)z-annex hook:before-load-<-> <->]} ${(on)ZINIT_EXTS2[(I)zinit hook:before-load-post <->]}) 
					for ___key in "${reply[@]}"
					do
						___arr=("${(Q)${(z@)ZINIT_EXTS[$___key]:-$ZINIT_EXTS2[$___key]}[@]}") 
						"${___arr[5]}" "$___type" "$___id" "${ICE[id_as]}" "${(j: :)${(q)@[2,-1]}}" "${(j: :)${(qkv)___ices[@]}}" "${${___key##(zinit|z-annex) hook:}%% <->}" load
						___retval2=$? 
						if (( ___retval2 ))
						then
							___retval+=$(( ___retval2 & 1 ? ___retval2 : 0 )) 
							(( ___retval2 & 1 && $# )) && shift
							if (( ___retval2 & 2 ))
							then
								local -a ___args
								___args=("${(@Q)${(@z)ZINIT[annex-before-load:new-@]}}") 
								builtin set -- "${___args[@]}"
							fi
							if (( ___retval2 & 4 ))
							then
								local -a ___new_ices
								___new_ices=("${(Q@)${(@z)ZINIT[annex-before-load:new-global-ices]}}") 
								(( 0 == ${#___new_ices} % 2 )) && ___ices=("${___new_ices[@]}")  || {
									[[ ${ZINIT[MUTE_WARNINGS]} != (1|true|on|yes) ]] && +zi-log "{u-warn}Warning{b-warn}:{msg} Bad new-ices returned" "from the annex{ehi}:{rst} {annex}${___arr[3]}{msg}," "please file an issue report at:{url}" "https://github.com/zdharma-continuum/${___arr[3]}/issues/new{msg}.{rst}"
									___ices=() ___retval+=7 
								}
							fi
							continue 2
						fi
					done
					integer ___action_load=0 ___turbo=0 
					if [[ -n ${(M)${+ICE[wait]}:#1}${ICE[load]}${ICE[unload]}${ICE[service]}${ICE[subscribe]} ]]
					then
						___turbo=1 
					fi
					if [[ -n ${ICE[trigger-load]} || ( ${+ICE[wait]} == 1 && ${ICE[wait]} = (\!|)(<->(a|b|c|)|) ) ]] && (( !ZINIT[OPTIMIZE_OUT_DISK_ACCESSES]
                    ))
					then
						if (( ___is_snippet > 0 ))
						then
							.zinit-get-object-path snippet $___ehid
						else
							.zinit-get-object-path plugin $___ehid
						fi
						(( $? )) && [[ ${zsh_eval_context[1]} = file ]] && {
							___action_load=1 
						}
						local ___object_path="$REPLY" 
					elif (( ! ___turbo ))
					then
						___action_load=1 
						reply=(1) 
					else
						reply=(1) 
					fi
					if [[ ${reply[-1]} -eq 1 && -n ${ICE[trigger-load]} ]]
					then
						() {
							builtin setopt localoptions extendedglob
							local ___mode
							(( ___is_snippet > 0 )) && ___mode=snippet  || ___mode="${${${ICE[light-mode]+light}}:-load}" 
							for MATCH in ${(s.;.)ICE[trigger-load]}
							do
								eval "${MATCH#!}() {
                                    ${${(M)MATCH#!}:+unset -f ${MATCH#!}}
                                    local a b; local -a ices
                                    # The wait'' ice is filtered-out.
                                    for a b ( ${(qqkv@)${(kv@)ICE[(I)^(trigger-load|wait|light-mode)]}} ) {
                                        ices+=( \"\$a\$b\" )
                                    }
                                    zinit ice \${ices[@]}; zinit $___mode ${(qqq)___id}
                                    ${${(M)MATCH#!}:+# Forward the call
                                    eval ${MATCH#!} \$@}
                                }"
							done
						} "$@"
						___retval+=$? 
						(( $# )) && shift
						continue
					fi
					if (( ${+ICE[if]} ))
					then
						eval "${ICE[if]}" || {
							(( $# )) && shift
							continue
						}
					fi
					for REPLY in ${(s.;.)ICE[has]}
					do
						(( ${+commands[$REPLY]} )) || {
							(( $# )) && shift
							continue 2
						}
					done
					integer ___had_cloneonly=0 
					ICE[wait]="${${(M)${+ICE[wait]}:#1}:+${(M)ICE[wait]#!}${${ICE[wait]#!}:-0}}" 
					if (( ___action_load || !ZINIT[HAVE_SCHEDULER] ))
					then
						if (( ___turbo && ZINIT[HAVE_SCHEDULER] ))
						then
							___had_cloneonly=${+ICE[cloneonly]} 
							ICE[cloneonly]="" 
						fi
						(( ___is_snippet )) && local ___opt="${(k)OPTS[*]}"  || local ___opt="${${ICE[light-mode]+light}:-${OPTS[(I)-b]:+light-b}}" 
						.zinit-load-object ${${${(M)___is_snippet:#1}:+snippet}:-plugin} $___id $___opt
						integer ___last_retval=$? 
						___retval+=___last_retval 
						if (( ___turbo && !___had_cloneonly && ZINIT[HAVE_SCHEDULER] ))
						then
							command rm -f $___object_path/._zinit/cloneonly
							unset 'ICE[cloneonly]'
						fi
					fi
					if (( ___turbo && ZINIT[HAVE_SCHEDULER] && 0 == ___last_retval ))
					then
						ICE[wait]="${ICE[wait]:-${ICE[service]:+0}}" 
						if (( ___is_snippet > 0 ))
						then
							ZINIT_SICE[$___ehid]= 
							.zinit-submit-turbo s${ICE[service]:+1} "" "$___id" "${(k)OPTS[*]}"
						else
							ZINIT_SICE[$___ehid]= 
							.zinit-submit-turbo p${ICE[service]:+1} "${${${ICE[light-mode]+light}}:-load}" "$___id" ""
						fi
						___retval+=$? 
					fi
				else
					___error=1 
				fi
				(( $# )) && shift
				___is_snippet=0 
			done
		else
			___error=1 
		fi
		if (( ___error ))
		then
			() {
				builtin emulate -LR zsh -o extendedglob ${=${options[xtrace]:#off}:+-o xtrace}
				+zi-log -n "{u-warn}Error{b-warn}:{rst} No plugin or snippet ID given"
				if [[ -n $___last_ice ]]
				then
					+zi-log -n " (the last recognized ice was: {ice}""${___last_ice/(#m)(${~ZINIT[ice-list]})/"{data}$MATCH"}{apo}''{rst}).{error}
You can try to prepend {apo}${___q}{lhi}@{apo}'{error} to the ID if the last ice is in fact a plugin.{rst}
{note}Note:{rst} The {apo}\`{ice}ice{apo}\`{rst} subcommand is now again required if not using the for-syntax"
				fi
				+zi-log "."
			}
			return 2
		elif (( ! $# ))
		then
			return ___retval
		fi
	}
	case "$1" in
		(ice) shift
			.zinit-ice "$@" ;;
		(cdreplay) .zinit-compdef-replay "$2"
			___retval=$?  ;;
		(cdclear) .zinit-compdef-clear "$2" ;;
		((add-|)fpath) .zinit-add-fpath "${@[2-correct,-1]}" ;;
		(run) .zinit-run "${@[2-correct,-1]}" ;;
		(man) man "${ZINIT[BIN_DIR]}/doc/zinit.1" ;;
		(env-whitelist) shift
			.zinit-parse-opts env-whitelist "$@"
			builtin set -- "${reply[@]}"
			if (( $# == 0 ))
			then
				ZINIT[ENV-WHITELIST]= 
				(( OPTS[opt_-v,--verbose] )) && +zi-log "{msg2}Cleared the parameter whitelist.{rst}"
			else
				ZINIT[ENV-WHITELIST]+="${(j: :)${(q-kv)@}} " 
				local ___sep="$ZINIT[col-msg2], $ZINIT[col-data2]" 
				(( OPTS[opt_-v,--verbose] )) && +zi-log "{msg2}Extended the parameter whitelist with: {data2}${(pj:$___sep:)@}{msg2}.{rst}"
			fi ;;
		(*) reply=(${ZINIT_EXTS[z-annex subcommand:${(q)1}]}) 
			(( ${#reply} )) && {
				reply=("${(Q)${(z@)reply[1]}[@]}") 
				(( ${+functions[${reply[5]}]} )) && {
					"${reply[5]}" "$@"
					return $?
				} || {
					+zi-log "({error}Couldn't find the subcommand-handler \`{obj}${reply[5]}{error}' of the z-annex \`{file}${reply[3]}{error}')"
					return 1
				}
			}
			(( ${+functions[.zinit-confirm]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-autoload.zsh" || return 1
			case "$1" in
				(zstatus) .zinit-show-zstatus ;;
				(delete) shift
					.zinit-delete "$@" ;;
				(times) .zinit-show-times "${@[2-correct,-1]}" ;;
				(self-update) .zinit-self-update ;;
				(unload) (( ${+functions[.zinit-unload]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-autoload.zsh" || return 1
					if [[ -z $2 && -z $3 ]]
					then
						builtin print "Argument needed, try: help"
						___retval=1 
					else
						[[ $2 = -q ]] && {
							5=-q 
							shift
						}
						.zinit-unload "${2%%(///|//|/)}" "${${3:#-q}%%(///|//|/)}" "${${(M)4:#-q}:-${(M)3:#-q}}"
						___retval=$? 
					fi ;;
				(bindkeys) .zinit-list-bindkeys ;;
				(update) if (( ${+ICE[if]} ))
					then
						eval "${ICE[if]}" || return 1
					fi
					for REPLY in ${(s.;.)ICE[has]}
					do
						(( ${+commands[$REPLY]} )) || return 1
					done
					shift
					.zinit-parse-opts update "$@"
					builtin set -- "${reply[@]}"
					if [[ ${OPTS[opt_-a,--all]} -eq 1 || ${OPTS[opt_-p,--parallel]} -eq 1 || ${OPTS[opt_-s,--snippets]} -eq 1 || ${OPTS[opt_-l,--plugins]} -eq 1 || -z $1$2${ICE[teleid]}${ICE[id-as]} ]]
					then
						[[ -z $1$2 && $(( OPTS[opt_-a,--all] + OPTS[opt_-p,--parallel] + OPTS[opt_-s,--snippets] + OPTS[opt_-l,--plugins] )) -eq 0 ]] && {
							builtin print -r -- "Assuming --all is passed"
						}
						(( OPTS[opt_-p,--parallel] )) && OPTS[value]=${1:-15} 
						.zinit-update-or-status-all update
						___retval=$? 
					else
						local ___key ___id="${1%%(///|//|/)}${2:+/}${2%%(///|//|/)}" 
						[[ -z ${___id//[[:space:]]/} ]] && ___id="${ICE[id-as]:-$ICE[teleid]}" 
						.zinit-update-or-status update "$___id" ""
						___retval=$? 
					fi ;;
				(status) if [[ $2 = --all || ( -z $2 && -z $3 ) ]]
					then
						[[ -z $2 ]] && {
							builtin print -r -- "Assuming --all is passed"
						}
						.zinit-update-or-status-all status
						___retval=$? 
					else
						.zinit-update-or-status status "${2%%(///|//|/)}" "${3%%(///|//|/)}"
						___retval=$? 
					fi ;;
				(report) if [[ $2 = --all || ( -z $2 && -z $3 ) ]]
					then
						[[ -z $2 ]] && {
							builtin print -r -- "Assuming --all is passed"
						}
						.zinit-show-all-reports
					else
						.zinit-show-report "${2%%(///|//|/)}" "${3%%(///|//|/)}"
						___retval=$? 
					fi ;;
				(plugins) .zinit-list-plugins "$2" ;;
				(snippets) .zinit-list-snippets "$2" ;;
				(completions) .zinit-show-completions "$2" ;;
				(cclear) .zinit-clear-completions ;;
				(cdisable) if [[ -z $2 ]]
					then
						builtin print "Argument needed, try: help"
						___retval=1 
					else
						local ___f="_${2#_}" 
						if .zinit-cdisable "$___f"
						then
							(( ${+functions[.zinit-forget-completion]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-install.zsh" || return 1
							.zinit-forget-completion "$___f"
							+zi-log "Initializing completion system ({func}compinit{rst}){…}"
							builtin autoload -Uz compinit
							compinit -d ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump} "${(Q@)${(z@)ZINIT[COMPINIT_OPTS]}}"
						else
							___retval=1 
						fi
					fi ;;
				(cenable) if [[ -z $2 ]]
					then
						builtin print "Argument needed, try: help"
						___retval=1 
					else
						local ___f="_${2#_}" 
						if .zinit-cenable "$___f"
						then
							(( ${+functions[.zinit-forget-completion]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-install.zsh" || return 1
							.zinit-forget-completion "$___f"
							+zi-log "Initializing completion system ({func}compinit{rst}){…}"
							builtin autoload -Uz compinit
							compinit -d ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump} "${(Q@)${(z@)ZINIT[COMPINIT_OPTS]}}"
						else
							___retval=1 
						fi
					fi ;;
				(creinstall) (( ${+functions[.zinit-install-completions]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-install.zsh" || return 1
					[[ $2 = -[qQ] ]] && {
						5=$2 
						shift
					}
					.zinit-install-completions "${2%%(///|//|/)}" "${3%%(///|//|/)}" 1 "${(M)4:#-[qQ]}"
					___retval=$? 
					[[ -z ${(M)4:#-[qQ]} ]] && +zi-log "Initializing completion ({func}compinit{rst}){…}"
					builtin autoload -Uz compinit
					compinit -d ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump} "${(Q@)${(z@)ZINIT[COMPINIT_OPTS]}}" ;;
				(cuninstall) if [[ -z $2 && -z $3 ]]
					then
						builtin print "Argument needed, try: help"
						___retval=1 
					else
						(( ${+functions[.zinit-forget-completion]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-install.zsh" || return 1
						.zinit-uninstall-completions "${2%%(///|//|/)}" "${3%%(///|//|/)}"
						___retval=$? 
						+zi-log "Initializing completion ({func}compinit{rst}){…}"
						builtin autoload -Uz compinit
						compinit -d ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump} "${(Q@)${(z@)ZINIT[COMPINIT_OPTS]}}"
					fi ;;
				(csearch) .zinit-search-completions ;;
				(compinit) (( ${+functions[.zinit-forget-completion]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-install.zsh" || return 1
					.zinit-compinit
					___retval=$?  ;;
				(compiled) .zinit-compiled ;;
				(compile|uncompile) (( ${+functions[.zinit-compile-plugin]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-autoload.zsh" || return 1
					local action="$1" all f help quiet 
					shift
					zparseopts -D -F -K -- {a,-all}=all {h,-help}=help {q,-quiet}=quiet || return
					if (( $#help ))
					then
						print "Usage:"
						print "  zinit ${0} <options> <plugin>"
						print " "
						print "Options:"
						print "  -a, --all       Checkout the specified branch"
						print "  -h, --help      Checkout the specified branch"
						print "  -q, --quiet     Checkout the specified tag or commit"
					fi
					if (( $#all ))
					then
						.zinit-compile-uncompile-all ${action}
						___retval="${?}" 
					else
						for f in ${(q+)^@}
						do
							.zinit-$action-plugin "${f}"
							(( ___retval += ${?} ))
						done
					fi ;;
				(debug) shift
					(( ${+functions[+zinit-debug]} )) || builtin source "${ZINIT[BIN_DIR]}/zinit-additional.zsh"
					+zinit-debug $@ ;;
				(cdlist) .zinit-list-compdef-replay ;;
				((c(hanges|d))|create|edit|glance|recall|stress) .zinit-"$1" "${@[2-correct,-1]%%(///|//|/)}"
					___retval=$?  ;;
				(recently) shift
					.zinit-recently "$@"
					___retval=$?  ;;
				(-h|--help|help) .zinit-help ;;
				(version) zi::version ;;
				(srv) () {
						setopt localoptions extendedglob warncreateglobal
						[[ ! -e ${ZINIT[SERVICES_DIR]}/"$2".fifo ]] && {
							builtin print "No such service: $2"
						} || {
							[[ $3 = (#i)(next|stop|quit|restart) ]] && {
								builtin print "${(U)3}" >>| ${ZINIT[SERVICES_DIR]}/"$2".fifo || builtin print "Service $2 inactive"
								___retval=1 
							} || {
								[[ $3 = (#i)start ]] && rm -f ${ZINIT[SERVICES_DIR]}/"$2".stop || {
									builtin print "Unknown service-command: $3"
									___retval=1 
								}
							}
						}
					} "$@" ;;
				(module) .zinit-module "${@[2-correct,-1]}"
					___retval=$?  ;;
				(*) if [[ -z $1 ]]
					then
						+zi-log -n "{b}{u-warn}ERROR{b-warn}:{rst} Missing a {cmd}subcommand "
						+zinit-prehelp-usage-message rst
					else
						+zi-log -n "{b}{u-warn}ERROR{b-warn}:{rst} Unknown subcommand{ehi}:{rst}" "{apo}\`{error}$1{apo}\`{rst} "
						+zinit-prehelp-usage-message rst
					fi
					___retval=1  ;;
			esac ;;
	esac
	return ___retval
}
zpcdclear () {
	.zinit-compdef-clear -q
}
zpcdreplay () {
	.zinit-compdef-replay -q
}
zpcompdef () {
	ZINIT_COMPDEF_REPLAY+=("${(j: :)${(q)@}}") 
}
zpcompinit () {
	autoload -Uz compinit
	compinit -d ${ZINIT[ZCOMPDUMP_PATH]:-${ZDOTDIR:-$HOME}/.zcompdump} "${(Q@)${(z@)ZINIT[COMPINIT_OPTS]}}"
}
zplugin () {
	zinit "$@"
}
# Shell Options
setopt autocd
setopt correct
setopt nohashdirs
setopt histexpiredupsfirst
setopt histfindnodups
setopt histignorealldups
setopt histignoredups
setopt histignorespace
setopt histreduceblanks
setopt histsavenodups
setopt interactivecomments
setopt login
setopt magicequalsubst
setopt nonomatch
setopt numericglobsort
setopt promptsubst
setopt sharehistory
# Aliases
alias -- ..='cd ..'
alias -- ...='cd ../..'
alias -- ....='cd ../../..'
alias -- deploy_staging='git tag eks-staging -f && git push origin eks-staging -f'
alias -- diff='diff --color=auto'
alias -- fsh-alias=fast-theme
alias -- ga='git add'
alias -- gc='git commit'
alias -- gl='git log --oneline'
alias -- gp='git push'
alias -- grep='grep --color=auto'
alias -- gs='git status'
alias -- la='eza --color=always --long --git --icons=always --all'
alias -- ll='eza --color=always --long --git --icons=always'
alias -- ls='eza --color=always --long --git --no-filesize --icons=always --no-time --no-user --no-permissions'
alias -- lt='eza --tree --color=always --icons=always'
alias -- run-help=man
alias -- which-command=whence
alias -- zi=zinit
alias -- zini=zinit
alias -- zpl=zinit
alias -- zplg=zinit
# Check for rg availability
if ! command -v rg >/dev/null 2>&1; then
  alias rg='/opt/homebrew/Cellar/ripgrep/14.1.1/bin/rg'
fi
export PATH=/Applications/SnowflakeCLI.app/Contents/MacOS/\:/Users/danielr/.bun/bin\:/Users/danielr/bin\:/Users/danielr/.local/bin\:/Users/danielr/.local/share/bob/nvim-bin\:/Users/danielr/go/bin\:/Users/danielr/.cargo/bin\:/opt/homebrew/bin\:/opt/homebrew/sbin\:/Users/danielr/.local/share/zinit/polaris/bin\:/Applications/SnowflakeCLI.app/Contents/MacOS/\:/usr/local/bin\:/System/Cryptexes/App/usr/bin\:/usr/bin\:/bin\:/usr/sbin\:/sbin\:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin\:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin\:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin\:/usr/local/go/bin\:/Applications/Ghostty.app/Contents/MacOS
